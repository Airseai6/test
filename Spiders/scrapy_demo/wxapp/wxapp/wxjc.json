{"title": "微信小程序开发早知道 ", "author": "Rolan", "pub_time": "2019-4-4 00:24", "content": "小程序没有跳转公众号、跳转公众号图文素材的能力。除非用户通过扫描二维码进入小程序的情景，可以显示关注公众号组件。公众号菜单、公众号图文素材可以打开小程序，网页无法直接打开小程序。小程序内嵌网页、内嵌网页中跳转链接、iframe 嵌套的页面，都必须在安全域名内，否则无法访问。如果想在小程序内加入第三方广告，要注意这点，因为安全域名修改是有次数限制的，并要求验证服务器。还要注意网页中嵌套 iframe 的情况，例如，网页内嵌了腾讯视频 iframe，由于腾讯视频不在安全域名内，会造成页面无法访问。用户信息授权、手机号码授权需要用户通过点击操作。小程序间跳转需要用户点击操作，跳转前需要用户确认，可跳转小程序数量不超过10个。小程序分为开发版、体验版、审核版、线上版：开发版是开发工具编辑过的最新版本；开发工具上传后成为体验版，具备体验权限的用户都可以查看；将开发版提交给官方审核后，成为审核版；审核成功后，才可以发布成为线上版本。官方「小程序助手」小程序可以很方便打开各版本小程序。每次发布新版本，用户都需要重新下载新版本。小程序仍在不断更新和完善，旧代码可能会因不符合新政策，在下次发布的时候无法正常运行。为避免这种情况的发生，应多关注官方公告。版本回退功能可以将线上版本回退成上一个版本小程序使用 CommonJS 规范，对 ES6 有很好的支持小程序没有官方状态管理工具，页面间通讯靠 query string 传递参数。如果有复杂状态管理的需求的话，建议引入一些设计模式或使用第三方框架。用户微信支付后，需要后台推送消息到服务器，才能确认支付成功。小程序的 DOM 操作只能查询属性，无法设置属性。小程序基础库版本与微信版本有关， 基础库版本与客户端版本对应关系 。小程序也存在兼容性问题，对待不愿更新微信的用户，要像对待忠实的IE6用户一样， 小程序基础库版本分布 。小程序页面只有 onLoad、onShow、onReady、onHide、onUnload 生命周期，没有更新视图相关的生命周期小程序不能直接渲染 HTML string，要用 rich-text 组件，但组件使用 HTML string 性能会有所下降。小程序有很多原生组件，如 Vedio、Map。原生组件位于最上层，会遮挡所有非原生组件，还存在诸多限制，如无法改变大小、无法添加动画效果等等。不过，有些组件在最新版本已经可以同层渲染了。小程序不支持摇一摇功能，但可以通过监听加速度传感器来实现。小程序有官方的广告组件，广告收入官方会抽走一部分。想到再更，欢迎补充."}
{"title": "微信，支付宝小程序实现原理概述 ", "author": "Rolan", "pub_time": "2019-3-25 00:35", "content": "微信小程序项目结构上图为微信小程序的项目结构，pages下面包含了小程序中的每一个页面，每一个页面由页面结构，页面样式，页面配置和逻辑代码四部分组成。页面结构页面结构文件为index.wxml，通过微信自定义的标签来写。页面逻辑页面逻辑通过JavaScript来书写。页面样式表类似CSS文件，来定义页面内元素的样式。页面配置页面内的权限等配置信息。微信小程序的技术选型小程序的定位特点是轻，快，针对这两个特点，在技术选型上，微信进行了一些考量。渲染界面的技术用纯客户端原生技术来渲染缺点：无法动态打包，动态下发。用纯 Web 技术来渲染缺点：如果我们用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题，这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。介于客户端原生技术与 Web 技术之间的，互相结合各自特点的技术来渲染从渲染底层来看，PhoneGap与微信 JS-SDK 是类似的，它们最终都还是使用浏览器内核来渲染界面。而 RN 则不同，虽然是用 Web 相关技术来编写，同样是利用了 JavaScript 解释执行的特性，但 RN 在渲染底层是用客户端原生渲染的。我们选择类似于微信 JSSDK 这样的 Hybrid 技术，即界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。微信没有选择RN的原因RN 所支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求，而对 RN 的改造具有不小的成本和风险。RN 现有能力下还存在的一些不稳定问题，比如性能、Bug等。RN 是把渲染工作全都交由客户端原生渲染，实际上一些简单的界面元素使用 Web 技术渲染完全能胜任，并且非常稳定。RN 存在一些不可预期的因素，比如之前出现的许可协议问题原生组件的渲染方式在安卓则是往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。Web渲染带来的问题与解决提供干净纯粹的JavaScript执行环境由于JavaScript的灵活性和浏览器的功能丰富，会导致很多不可控的隐私，因此，微信提供了一个单纯的JS执行环境，通过对于其中的控件也进行了自定义。因此完全采用这个沙箱环境不能有任何浏览器相关接口，只提供纯JavaScript 的解释执行环境，那么像HTML5中的ServiceWorker、WebWorker特性就符合这样的条件，这两者都是启用另一线程来执行 JavaScript。但是考虑到小程序是一个多 WebView 的架构，每一个小程序页面都是不同的WebView 渲染后显示的，在这个架构下我们不好去用某个WebView中的ServiceWorker去管理所有的小程序页面。得益于客户端系统有JavaScript 的解释引擎（在iOS下是用内置的 JavaScriptCore框架，在安卓则是用腾讯x5内核提供的JsCore环境），我们可以创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，也就是我们前面一直提到的逻辑层。而界面渲染相关的任务全都在WebView线程里执行，通过逻辑层代码去控制渲染哪些界面，那么这一层当然就是所谓的渲染层。这就是小程序双线程模型的由来。标签自定义为了防止标签定义带来的一些问题，微信自定义了一套标签语言，WXML，这套标签语言经过编译之后，最终会生成Html。渲染与逻辑的分离上面是小程序的渲染技术的选型，在选型之后，由于渲染和逻辑不再同一个浏览器执行，一个在纯JS环境中，一个通过WebView渲染，因此小程序的运行环境分成渲染层和逻辑层，WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型如图所示。数据驱动视图变化在开发UI界面过程中，程序需要维护很多变量状态，同时要操作对应的UI元素。随着界面越来越复杂，我们需要维护很多变量状态，同时要处理很多界面上的交互事件，整个程序变得越来越复杂。通常界面视图和变量状态是相关联的，如果有某种“方法”可以让状态和视图绑定在一起（状态变更时，视图也能自动变更），那我们就可以省去手动修改视图的工作。小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。事件的处理UI界面的程序需要和用户互动，例如用户可能会点击你界面上某个按钮，又或者长按某个区域，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户。由于WebView现在具备的功能只是进行渲染，因此对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理。事件的派发处理，具备事件捕获和冒泡两种机制。通过native传递给JSCore，通过JS来响应响应的事件之后，对Dom进行修改，改动会体现在虚拟Dom上，然后再进行真实的渲染。数据通信小程序是基于双线程模型，那就意味着任何数据传递都是线程间的通信，也就是都会有一定的延时。这不像传统Web那样，当界面需要更新时，通过调用更新接口UI就会同步地渲染出来。在小程序架构里，这一切都会变成异步。异步会使得各部分的运行时序变得复杂一些。比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来，如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作。因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信。逻辑层向视图层发送页面数据（data和setData的内容），视图层向逻辑层反馈用户事件。通过Json的方式进行数据的传递，提高性能的方式就是减少交互的数据量。缓存机制小程序宿主环境会管理不同小程序的数据缓存，不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为10MB，如果当前缓存已经达到10MB，再通过wx.setStorage写入缓存会触发fail回调。小程序的本地缓存不仅仅通过小程序这个维度来隔离空间，考虑到同一个设备可以登录不同微信用户，宿主环境还对不同用户的缓存进行了隔离，避免用户间的数据隐私泄露。由于本地缓存是存放在当前设备，用户换设备之后无法从另一个设备读取到当前设备数据，因此用户的关键信息不建议只存在本地缓存，应该把数据放到服务器端进行持久化存储。支付宝小程序支付宝小程序简介支付宝小程序的实现和微信小程序的实现方式大致是相同的，因此这里主要针对两者的差异性的地方。支付宝小程序目录结构支付宝小程序业务架构图在渲染引擎上面，支付宝小程序不仅提供 JavaScript+Webview 的方式，还提供 JavaScript+Native 的方式，在对性能要求较高的场景，可以选择 Native 的渲染模式，给用户更好的体验。运行时架构小程序编程模型是分为多个页面，每个页面有自己的 template、CSS 和 JS，实际在运行的时候，业务逻辑的 JS 代码是运行在独立的 JavaScript 引擎中，每个页面的 template 和 CSS 是运行在各自独立的 webview 里面，页面之间是通过函数 navigateTo 进行页面的切换。每个 webview 里面的页面和公共的 JavaScript 引擎里面的逻辑的交互方式是通过消息服务，页面的一些事件都会通过这个消息通道传给 JavaScript 引擎运行环境，这个运行环境会响应这个事件，做一些 API 调用，可调到客户端支付宝小程序提供的一些能力，处理之后会把这个数据再重新发送给对应的页面渲染容器来处理，把数据和模板结合在一起来，在产生最终的用户界面。支付宝小程序虚拟机隔离通常的做法是在 WebView 里面运行 render 的代码，然后另起一个线程运行 serviceworker，当 serviceworker 需要更新 dom 的时候把事件和数据通过 messagechannel 发送给 render 线程来执行，当业务需要传递到 render 层数据量较大，对象较复杂时，交互的性能就会比较差，因此针对这种情况我们提出一个优化的解决方案。该方案将原始的 JS 虚拟机实例 (即 Isolate) 重新设计成了两个部分：Global Runtime 和 Local Runtime。Global Runtime 部分是存放共享的装置和数据，全局一个实例。Local Runtime 是存放实例自身相关的模块和私有数据，这些不会被共享。在新的隔离模型下，webview 里面的 v8 实例就是一个 Local Runtime，worker 线程里面的 v8 实例也是一个 Local Runtime，在 worker 层和 render 层交互时，setData 对象的会直接创建在 Shared Heap 里面，因此 render 层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，减少了对象的序列化和网络传输，极大的提升了启动性能和渲染性能。首屏速度优化由于小程序启动是受到生命周期的控制，从 onLaunch -> onLoad -> onShow -> onReady -> 用户操作 -> 离开首页这个流程，在这个过程中的任意一个环节都有可能被客观或者主观的原因打断，也就有可能导致保存的离线页面不准确，在启动的时候给用户呈现错误的页面。所以对于首页离线缓存渲染的效果，保存页面的时机很重要，我们提供让开发者可以配置的时机，配置的时机有两个：渲染完成和离开首页前。对于渲染完成就是首页渲染完成，用户还未执行任何的操作前把页面保存下来作为离线缓存的页面。离开首页前就是指用户在首页执行了一系列的操作后，跳转到其他页面前用户看到的页面保存下来作为离线缓存的页面。对于闪屏问题发生的场景是因为缓存页面和真实渲染的页面是分离的，是两个独立的页面，缓存页面是静态的页面，真实的页面是通过 js 动态创建的页面，所以常规的做法就是当真实页面创建完成后替换缓存的页面，这样的情况下就会发生闪屏。针对这个问题，我们是采用虚拟 dom 来解决，在加载缓存页面的时候把缓存页面放入初始的虚拟 dom 里面，真实页面创建后产生的虚拟 dom 跟缓存页面的虚拟 dom 进行 dom diff，把变化的内容通过 patch 传给浏览器内核，渲染对应的页面，这样就可以只更新局部有变化的页面内容，避免了整个页面的更新，也保证内容的准确性和实时性。支付宝采用UC浏览器内核优势1. 图片内存 ：针对低端机，做了更严格的图片缓存限制，在保持性能体验的情况下，进一步限制图片缓存的使用；多个 webview 共用图片缓存池；全面支持 webp、apng 这种更节省内存和 size 的图片格式。2. 渲染内存 ：Webview 在不可见的状态下，原生的内存管理没有特殊处理，UC 内核会将不可见 webview 的渲染内存释放；渲染内存的合理设置与调优，避免滚动性能的下降和占用过多内存。3. JS 内存 ：更合理地处理 v8 内存 gc，在启动时延时执行 full gc，避免影响启动的耗时。4. 峰值内存管理 ：系统在内存紧张时，会通知内核，UC 内核能够在系统低内存时释放非关键内存占用的模块，避免出现 oom，也避免过度释放带来的渲染黑块；在部分 oom 的情况，规避原生内核主动崩溃的逻辑，在内存极低的情况，部分功能不可用，而不是崩溃。对我们的启示小程序存储管理增加小程序的存储，包括内存和磁盘，可以缓存部分数据，增加页面直出速度。同时对于磁盘的管理，按照小程序账号双重维度进行划分。第三方业务接入能力限制在支持第三方的接入之后，按照现有方式将会导致对于安全和第三方的行为完全不可控，可以参考微信，支付宝方式采用自定义标记语言的方式对标记语言做限制，并提供纯净的JS环境来进行JS环境的执行，WebView只负责渲染。首屏速度参考支付宝方案，在加载的时候，现将老的页面呈现给用户，然后在新页面完成之后，计算差值，再进行显示。Native绘制结合Native绘制采用通过JS和Native通信的方式，将Native控价加入到布局的制定区域。网络请求发送托管网络请求等全部交由Native托管，更好的控制网络请求，监控网络请求。"}
{"title": "微信小程序拉起登录的操作 ", "author": "Rolan", "pub_time": "2019-3-26 00:37", "content": "第一步，前端调用wx.login()接口把token数据请求过来，第二部，把tok嗯发送到总计的服务器，然后进行微信openid和assession的获取第三部验证session是否过期，过期重新拉起授权登录，未过期直接进行下一步第四部：getUserInfo，获取用户的个人信息，// pages/authorize/authorize.js\r\nPage({\r\n  data:{\r\n    img:'',\r\n    pri:'',\r\n    city:'',\r\n    nickname:''\r\n  },\r\n  login(){\r\n    wx.login({\r\n      success:res=>{\r\n        // 可以获取code\r\n        console.log(res)\r\n        wx.request({\r\n          url: 'http://flyxin.com.cn/login.php', // 仅为示例，并非真实的接口地址\r\n          data: {\r\n            code:res.code\r\n          },\r\n          header: {\r\n            'content-type': 'application/json' // 默认值\r\n          },\r\n          success(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  checksession(){\r\n    wx.checkSession({\r\n      success:function(red){\r\n        console.log(red,'未过期');\r\n        wx.showToast({\r\n          title: '登录未过期',\r\n        })\r\n      },\r\n      fail:function(res){\r\n        console.log(res)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '登录已过期',\r\n        })\r\n        // 再次调用login\r\n\r\n      }\r\n    })\r\n  },\r\n  // 获取用户信息\r\n  info(){\r\n    wx.getUserInfo({\r\n      success:(res)=>{\r\n        console.log(res.userInfo)\r\n        var json=res.userInfo;\r\n        this.setData({\r\n          nickname:json.nickName,\r\n          pri: json.province,\r\n          city:json.city,\r\n          img:json.avatarUrl\r\n        })\r\n      }\r\n    })\r\n  }\r\n}) 希望自己写的东西能够对大家有所帮助！谢谢"}
{"title": "Taro + 云开发实战|日语用例助手 ", "author": "Rolan", "pub_time": "2019-3-27 00:11", "content": "原创： Evont前言小程序开放了云开发能力，为开发者提供了一个可以很快速构建小程序后端服务的能力，作为一名对新技术不倒腾不快的前端，对此也是很感兴趣的。Taro 是凹凸实验室推出的，基于React 语法规范的多端开发解决方案，较之于mpvue或者wepy，由于年轻，坑还比较多，但是很适合我这种倾向用React 开发的人。我结合这两者，使用cheerio和superagent 抓取了用例.jp， 开发了一个《日语用例助手》。入门踩坑1.云开发篇1.1 环境搭建云开发可以通过下列两种方式创建： 1.使用quickstart（云开发快速启动模版）创建项目：这种方式会在目录下同时创建名为miniprogram ，带有云开发调用范例的小程序基础模板和名为cloudfuntions 的存放云函数的目录, 由此即可开始全新的项目。2.基于现有的小程序使用云开发：在小程序目录下创建一个文件夹作为你的云函数目录，然后在project.config.json 文件中新增字段\"cloudfunctionRoot\": \"你的云函数目录\"，即可以在微信开发者工具中看到目录的图标变成了云，在此目录下创建云函数即可；1.2 云函数编写使用微信开发者工具在云函数目录下创建一个云函数时，会根据名称创建一个目录，目录中包含一个index.js 和package.json。在小程序中使用如下方式调用云函数：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      key1: 'value1',\r\n      key2: 'value2'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((e) => {\r\n    console.log(e);\r\n});复制代码index.js的入口函数如下所示：//云函数入口函数\r\nexports.main = async (event, context) => {\r\n    // 参数获取在event 中获取，如使用上面的调用函数后，获取data使用 event.key1、event.key2即可\r\n    const { key1, key2 } = event;\r\n    return { query: { key1, key2 } }\r\n}复制代码每个云函数可视为一个单独的服务，如果需要安装第三方依赖，只需要在该目录点击右键，选择 在终端中打开, 并 npm install依赖即可。需要注意的是，每个云函数都是独立的，所需要的依赖都需要在对应的目录下进行 npm install，但这样就会使得项目变得十分庞大且不优雅。因此，接下来我介绍一下tcb-router。1.3 使用tcb-router管理路由tcb-router 是腾讯云团队开发的，基于 koa 风格的小程序·云开发云函数轻量级类路由库，主要用于优化服务端函数处理逻辑。使用tcb-router的方法很简单：const TcbRouter = require('tcb-router');\r\nexports.main = (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    app.router('路由名称', async (ctx) => {\r\n        //原有的event需要通过ctx._req.event 获取\r\n        const { param1, param2 } = ctx._req.event;\r\n        ctx.body = { key1: value1 };\r\n    });\r\n})复制代码此时小程序的调用方式也需要改成：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      $url: '路由名称',\r\n      // 其他数据\r\n      param1: 'test1',\r\n      param2: 'test2'\r\n    },\r\n    success: res => {},\r\n    fail: err => {\r\n      console.error(`[云函数] [${action}] 调用失败`, err)\r\n          }\r\n})复制代码2.Taro篇2.1 环境搭建npm install -g @tarojs/cli\r\ntaro init myApp复制代码2.2 遇到的坑1.API支持不足由于Taro 对微信的一些新api 并没有支持到，比如使用云开发时需要用到 wx.cloud，Taro 并没有支持，但亲测是可以直接使用 wx 变量，但是会被eslint 提醒，看着十分不悦，可以在 .eslintrc 文件中增加以下代码：\"globals\": {\r\n  \"wx\": true\r\n},复制代码2.不能使用 Array#map 之外的方法操作 JSX 数组。3.不允许在 JSX 参数(props)中传入 JSX 元素(taro/no-jsx-in-props)。3.爬虫篇3.1 superagentsuperagent 是一个非常实用的http请求模块，用来抓取网页十分有用，使用也十分简单，以下是我在抓取 yourei.jp 时使用的代码：// const superagent = require('superagent');\r\n// ...\r\nfunction crawler(url, cb) {\r\n  return new Promise((resolve, reject) => {\r\n    superagent.get(url).set({\r\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'\r\n    }).end(function (err, res) {\r\n      if (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n      resolve(res);\r\n    });\r\n  });\r\n}复制代码3.2 cheeriocheerio 是一个轻型灵活，类jQuery的对HTML元素分析操作的工具。在进行一些server端渲染的页面以及一些简单的小页面的爬取时，cheerio十分好用且高效。在使用 superagent 抓取了网页内容后，可以使用如下方式解析页面代码:// const cheerio = require('cheerio');\r\n    // ...\r\n    const result = crawler(apiUrl).then((res) => {\r\n      // 使用load 之后，$ 即可同jquery 一样使用选择器来选择元素了\r\n      const $ = cheerio.load(res.text);\r\n      const categories = [];\r\n      $('[data-toggle]').each((i, ele) => {\r\n        // 可以使用.text()、.html() 等方式获取元素的内容\r\n        categories.push($(ele).attr('href'));\r\n      });\r\n      return {\r\n        list: categories,\r\n      };\r\n    });复制代码总结1.Taro如果你是React 开发者，需要开发多端小程序，或者原有React 项目想迁移到小程序，Taro 是个不错的选择，但还有很多坑没有填好，希望它的发展越来越好。2.云开发如果你是个人开发者，想尝试小程序开发又不想或者难以自己搭建服务器，云开发是个好选择，容易上手且十分敏捷。"}
{"title": "提高一些开发小程序和云函数的效率 ", "author": "Rolan", "pub_time": "2019-3-27 00:34", "content": "一开始开发小程序都是使用微信自带的开发工具，由于起初对小程序不是很熟悉，也没觉得开发效率低，但渐渐熟悉之后发现，用自带的开发工具效率实在太低了。吐槽下自带的开发工具主要有两点吧，第一个是可写代码的区域少的可怜。调试器、模拟区不隐藏的话，编辑区域是屏幕的一半都不到。而且没办法分屏，外接显示屏也派不上用场。另外一个就是智能提示部分了，也是少的可怜。用惯了宇宙第一神器 Visual Studio ,编码能力已经退化了，没有提示有时候效率真的比较低。至于其他的一些小问题其实还好。推荐使用vscode现在 vscode 真的越来越强大了，体验也相当好，推荐使用。简单的装几个插件就可以轻松编写小程序代码了。首先安装 minapp ,支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。然后安装 wxml ,这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。有这两个插件其实基本已经够用，其实还有很多基于小程序的插件，看个人喜好和习惯了。这样双屏也有用武之地了，一个屏利用 vscode 进行编码，另一个屏用来调试和查看效果(将编辑器隐藏)，效率提升很多。本地调试云函数有用到云函数的话建议先在本地调试后再上传，效率会高很多，现在云函数上传一次的时间时快时慢，同时在云端调试只能打日志，不能断点调试。小程序的云函数本质也是nodejs，所以在本地确保有相应的node环境之后，写个简单的调用的test文件就可以进行本地调试了。举个简单例子，有一个对应的云函数 index.js ，为了方便直接在对应目录下新建一个 test.js 文件，如下截图：test.js相关代码如下,简单调用：const cloud = require('wx-server-sdk')\r\ncloud.init({ secretId: '', secretKey: '', env: '' })\r\n\r\nvar exports_mode = require('./index.js')\r\nvar event = { }\r\nexports_mode.main(event, null)需要注意的是如果使用到 云数据 或者 云存储 的话，需要引用 wx-server-sdk ,而要初始化该模块需要到腾讯云上申请相应的秘钥。申请地址：https://console.cloud.tencent.com/cam/capi最后通过 npm install 下载对应的依赖，然后就可以直接 F5 调试啦，可以看到截图已经进入到云函数方法的断点处了。总结前段时间一直很忙，现在终于可以挤出点时间继续搞我的小程序了，持续分享中。"}
{"title": "TypeScript 自动编译脚本的实现 ", "author": "Rolan", "pub_time": "2019-3-28 00:13", "content": "引言万法归一， TypeScript 似有一统前台的趋势。微信小程序也引入了 TypeScript ，我们也要跟随技术主流将小程序从 JavaScript 切换到 TypeScript 。微信小程序现在没之前那么火爆了，但仍我我们跨平台开发的明智。其实不管微信有小程序，支付宝、百度、 QQ 浏览器都相继上线小程序，还有手机联盟( vivo 、 oppo 、华为等多家手机公司共同成立的)创建的快应用也狠狠地抄了腾讯一把，代码简直一模一样。小程序最火爆的时期要属去年清明节，小游戏横空出世，同时带火了小程序，周围的朋友都在用小程序、小游戏。记得当时还利用几天的假期时间，调用豆瓣开发的 api ，开发了一款名为豆瓣电影的小程序。可惜，最终没能上架，拒绝原因是该应用属于信息服务类的程序，禁止个人开发者申请。当时是使用 ZanUI 开发的，经历了一个自己玩的小项目，也算对微信小程序有了一个全面的理解。需求使用 TypeScript 重搭一次微信小程序的架子，今后的小程序使用 TypeScript 开发。实现基础工作建项目和之前没什么区别，就是在语言一栏需要选择 TypeScript 。其实使用 TypeScript 和 JavaScript 对于微信开发者工具来说没什么区别，用 TypeScript 也是编译成 JavaScript 再执行。这里不推荐直接使用微信开发者工具编写 TypeScript ，因为没有提示，我是采用 WebStorm安装微信插件进行开发，然后打开微信开发者工具查看效果的。一路顺风，没什么问题。在 UI 框架选型上，我选择了 ColorUI 。为什么选择这个呢？虽然之前用过的 ZanUI 也很好用，也很全，但我第一眼看到 ColorUI 的时候，我被惊艳到了。再点进去组件查看，我猜想这个作者一定有过很多次的手机端页面开发经验，真的是每一个组件你都能用到，为作者点个赞。缺点就是文档不完善，但我认为这个 Demo 写得足够优秀了，直接 clone 下来，想要的都有了，剩下的就是改改字。希望以后当我有时间的时候，能给 ColorUI 的文档提交一些 Pull Request ，也算是感谢作者写出了这么好的 UI 库并分享给大众。非常好用，只需要去框架里粘一粘代码，漂亮的原型就出来了，挺好用的。自动编译写的时候遇到了点问题，就是编译的问题。微信开发者工具执行的是 js 文件，我编写的是 ts 文件，假设我修改了 ts 文件，我想看到修改后的效果，我需要手动编译，这就不优雅了。我们用过的 grunt 、 ng ，哪个不是自动编译、自动刷新？既然小程序没提供，那只能另谋生路了。突然想起 ng 不也是 nodejs 里的命令吗？它能监听文件自动编译，我为什么不试试看呢？nodenode.js 不是一个框架，而是一个高效的 JavaScript 运行环境。所以， node.js 脚本说到底就是一个 js 文件，没什么难的。在微服务中，我们常用 node.js 搭建反向代理服务器，其性能与 nginx 部分伯仲。自动化脚本新建脚本 yunzhi.js ，代码很简单，相信有编程基础的人都能看懂，这里就不再赘述。const exec = require('child_process').exec;\r\nconst watch = require('node-watch');\r\n\r\nwatch(['app.ts', 'specs', 'pages'], { recursive: true }, function(evt, name) {\r\n    if (name.split('.').pop() === 'ts') {\r\n        console.log('监听到TypeScript文件改动，重新编译中...');\r\n        exec('npm run compile');\r\n    }\r\n});\r\n\r\nconsole.log('云智TypeScript自动编译脚本已成功运行...');总结不了解，就以为很难，其实当你勇敢地迈出第一步的时候，问题就已经解决。因为你觉得自己行，你真的就行。"}
{"title": "小程序Checkbox全选 ", "author": "Rolan", "pub_time": "2019-3-28 00:32", "content": "这是我写的第一篇文章，若有不对，请大家指正，多谢！这篇文章主要讲小程序的全选。接触小程序没有太久，我想每实现一个功能就在这里记录一次，以此巩固。其实实现很简单，在每个选择集合中加入一个isCheck字段，默认是false（未选中），然后wxml页面中循环list时，给checkbox加一个属性：checked='{{item.isCheck}}'；接下来是js，在全选按钮上绑定事件：checkAll。js中首选要得到所有的list（var list = that.data.Data）;然后for循环list，在循环中让每一个isCheck取反；之后，在循环外setData我们上文声明的list：that.setData({Data:list}),意思就是把我们操作过的list重新赋给Data，页面会重新渲染；废话不多说，以下是代码：  wxml:\r\n    <view class='atte-title'>\r\n      <view class='odb-title-left'>选择参会人</view>\r\n      <checkbox value='全选' bindtap='checkAll'></checkbox>\r\n    </view>\r\n    <checkbox-group bindchange='change'>\r\n      <block wx:for='{{Data}}' wx:key>\r\n        <checkbox value='{{item.name}}' checked='{{item.isCheck}}' class='check-item' style='background:#fff;'>\r\n          <view class='check-box'>\r\n            <view class='atte-ava'>\r\n              <image src='{{item.Image}}'></image>\r\n            </view>\r\n            <view class='atte-name'>{{item.name}}</view>\r\n            <view class='atte-point'>\r\n              <image src='/images/Articles/point.png'></image>\r\n            </view>\r\n            <view class='atte-pro'>{{item.partyBranchJobTypeName}}</view>\r\n          </view>\r\n        </checkbox>\r\n      </block>\r\n    </checkbox-group>  // 全选\r\n  checkAll: function (e) {\r\n    var that = this\r\n    console.log(that.data.Data)\r\n    var list = that.data.Data  \r\n    for (var i = 0; i < list.length;++i){\r\n      list[i].isCheck = !list[i].isCheck || false;  //list[i].isCheck默認是false,这里是取反\r\n    }\r\n    that.setData({\r\n      Data:list,         //将取反后的集合setData到我们的Data\r\n    })\r\n  },小白一枚，水平很差，请多指教；"}
{"title": "小程序通过用户授权获取手机号之getPhoneNumber ", "author": "Rolan", "pub_time": "2019-3-13 18:38", "content": "小程序有一个获取用户很便捷的api，就是通过getPhoneNumber获取用户的已经绑定微信的手机号码。有一点要大家注意，现在微信和注重用户体验，有些方法都是需要用户主动去触发才能调用的，比如getPhoneNumber。官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html实现思路：直接上干货：<button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\"></button>JS内getPhoneNumbe组件函数（该事件中最重要的就是在wx.login登录后发起接口请求），这里需要配置参数来给接口： 这些是必不可少的参数，这些齐备才能算一个合法的请求。appid: “你的小程序APPID”,secret: “你的小程序appsecret”,code: res.code,encryptedData: telObj,iv: ivObj最终结果展示：点击\"拒绝\"，开发者能捕捉到该事件 ，此时getPhoneNumber 函数返回 e.detail.errMsg 为 getPhoneNumber:user deny"}
{"title": "小程序自定义单页面、全局导航栏 ", "author": "Rolan", "pub_time": "2019-3-15 00:34", "content": "需求产品说小程序返回到首页不太方便，想添加返回首页按钮，UI说导航栏能不能设置背景图片，因为那样设计挺好看的。需求分析并制定方案这产品和UI都提需求了，咱也不能反驳哈，所以开始调研，分析可行性方案；1、可以添加悬浮按钮。2、自定义导航栏。添加悬浮按钮，是看起来是比较简单哈，但是感觉不太优雅，会占据页面的空间，体验也不太好。所以想了下第二种方案，自定义导航栏既可以实现产品的需求还可以满足UI的设计美感，在顶部空白处加上返回首页的按钮，这样和返回按钮还对称（最终如图所示，顶部导航栏是个背景图片，分两块组合起来）。实现方案一、实现的前提1、首先查看文档，看文档里关于自定义导航栏是怎么规定的，有哪些限制；下面分别是小程序自定义导航栏全局配置和单页面配置的微信版本和调试库的最低支持版本。在app.json window 增加 navigationStyle:custom ，顶部导航栏就会消失，只保留右上角胶囊状的按钮，如何修改胶囊的颜色呢;胶囊体目前只支持黑色和白色两种颜色 在app.josn window 加上 \"navigationBarTextStyle\":\"white/black\"还要考虑加返回按钮和返回首页的按钮，适配不同的机型先说下两种配置方法：①全局配置navigationStyle：调试基础库>=1.9.0微信客户端>=6.6.0app.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"navigationBar\": \"/components/navigationBar/navigationBar\"\r\n  },\r\n  \"window\": {\r\n    \"navigationStyle\": \"custom\"\r\n  } \r\n}单页面配置navigationStyle调试基础库>=2.4.3微信客户端版本>=7.0.0自定义的页面.json\r\n\r\n{\r\n  \"window\": {\r\n    \"navigationStyle\": \"default\"\r\n  } \r\n}\r\n{\r\n  \"navigationStyle\": \"custom\",\r\n  \"usingComponents\": {\r\n    \"navigationBar\": \"/components/navigationBar/navigationBar\"\r\n  }\r\n}两者的区别就是，全局配置放在app.json文件里，单页面配置放在自定义页面配置文件里。二、实现的步骤以下说下几个要点：1、自定义导航栏文本，是否显示返回，是否显示返回首页,导航栏高度2、statusBarHeight，用来获取手机状态栏的高度，这个需要在全局app.js中的onLaunch，调用wx.getSystemInfo获取，navigationBarHeight+默认的高度，这个是设定整个导航栏的高度，3、还有注意的，在写样式距离和大小时建议都用px，因小程序右边的胶囊也是用的px，不是rpx。4、因为自定义导航栏每个页面都要写，所以把导航栏封装了公共组件，这样只需要在每个页面引入即可。如下是封装的导航栏组件：wxml<view class=\"navbar\" style=\"{{'height: ' + navigationBarHeight}}\">\r\n  <view style=\"{{'height: ' + statusBarHeight}}\"></view>\r\n  <view class='title-container'>\r\n    <view class='capsule' wx:if=\"{{ back || home }}\">\r\n      <view bindtap='back' wx:if=\"{{back}}\">\r\n        <image src='/images/back.png'></image>         \r\n      </view>\r\n      <view bindtap='backHome' wx:if=\"{{home}}\">\r\n        <image src='/images/home.png'></image>\r\n      </view>\r\n    </view>\r\n    <view class='title'>{{text}}</view>\r\n  </view>\r\n</view>\r\n<view style=\"{{'height: ' + navigationBarHeight}};background: white;\"></view>这里有个需注意的问题，就是一般会出现自定义导航栏，下拉页面，导航栏也随着会下拉，这种问题是因为设置fixed后页面元素整体上移了navigationBarHeight，所以在此组件里设置一个空白view元素占用最上面的navigationBarHeight这块高度wxss.navbar {\r\n  width: 100%;\r\n  background-color: #1797eb;\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  z-index: 999;\r\n}\r\n.title-container {\r\n  height: 40px;\r\n  display: flex;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n.capsule {\r\n  margin-left: 10px;\r\n  height: 30px;\r\n  background: rgba(255, 255, 255, 0.6);\r\n  border: 1px solid #fff;\r\n  border-radius: 16px;\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n.capsule > view {\r\n  width: 45px;\r\n  height: 60%;\r\n  position: relative;\r\n.capsule > view:nth-child(2) {\r\n  border-left: 1px solid #fff;  \r\n}\r\n.capsule image {\r\n  width: 50%;\r\n  height: 100%;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%,-50%);\r\n}\r\n.title {\r\n  color: white;\r\n  position: absolute;\r\n  top: 6px;\r\n  left: 104px;\r\n  right: 104px;\r\n  height: 30px;\r\n  line-height: 30px;\r\n  font-size: 14px;\r\n  text-align: center;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}jsconst app = getApp()\r\n\r\nComponent({\r\n\r\n  properties: {\r\n    text: {\r\n      type: String,\r\n      value: 'Wechat'\r\n    },\r\n    back: {\r\n      type: Boolean,\r\n      value: false\r\n    },\r\n    home: {\r\n      type: Boolean,\r\n      value: false\r\n    }\r\n  },\r\n  data: {\r\n    statusBarHeight: app.globalData.statusBarHeight + 'px',\r\n    navigationBarHeight: (app.globalData.statusBarHeight + 44) + 'px'\r\n  },\r\n\r\n  methods: {\r\n    backHome: function () {\r\n      let pages = getCurrentPages()\r\n      wx.navigateBack({\r\n        delta: pages.length\r\n      })\r\n    },\r\n    back: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      })\r\n    }\r\n  }\r\n})json{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}最终还需要考虑下版本兼容的问题，毕竟还有一些用户，微信版本并没有更新到最新版本。首先可以在app.js里面获取下当前用户的微信版本，做下版本比较，如果小于这个版本，设置个全局变量，也可以在组件写个方法，在不同的页面打开显示不同的顶部导航栏，或者可以控制是否显示导航栏，这里就不详细说了。亲自试了下，在低于7.0版本的微信中，如果采用单页面自定义导航栏，会出现两个导航栏，这时候通过判断版本号不要再渲染自定义的导航栏组件了，在页面的配置文件里写上title名，还有相应的背景色，这样就会显示自带的导航栏了。总结小程序开发是有些坑的地方，从不支持自定义导航栏，到支持全局自定义导航栏，再到现在的支持单页面配置，可以看出在慢慢完善。还有底部tabbar，可自己选择配置的太少了，虽然也支持自定义，但是发现自定义写的底部导航组件体验并不好，每次打开页面都会重新渲染底部的按钮，如果全部写成在一个页面里的tab切换，虽然按钮每次不用重新加载了，但是业务多肯定不行，写到一个单页面里东西也太多了。 希望微信能够多添加或放开一些功能，让开发者更好的服务于产品，给用户更好的体验。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序获得openid免密登录 ", "author": "Rolan", "pub_time": "2018-12-28 00:38", "content": "{\r\n  wx.login({\r\n    success: res => {\r\n      let d = {\r\n        appid: 'wx111111111111', // 从微信公众平台开发设置中获取\r\n        secret: 'sec2222222222' // 从微信公众平台开发设置中获取\r\n      };\r\n      // 微信官方的获取openid的接口\r\n      var wxLoginUrl = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + d.appid +'&secret=' \r\n      + d.secret + '&js_code=' + res.code + '&grant_type=authorization_code';\r\n      wx.request({\r\n        url: wxLoginUrl,\r\n        data: {},\r\n        method: 'GET',\r\n        success: res => {\r\n           let openid = res.data.openid;\r\n          this.judgeIsWxlogin(openid); // 向后端发送openid判断是否可以直接用该微信号登陆\r\n        }\r\n      });\r\n    }\r\n  });\r\n}从微信公众平台开发设置中获取appid和secret:"}
{"title": "微信小程序发送短信验证码完整实例 ", "author": "Rolan", "pub_time": "2019-1-7 00:36", "content": "微信小程序注册完整实例，发送短信验证码，带60秒倒计时功能，无需服务器端。效果图:代码:index.wxml<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view class='row'>\r\n     <input placeholder='请输入姓名' bindinput='bindNameInput'/> \r\n  </view>\r\n  \r\n  <view class='row'>\r\n     <input placeholder='请输入手机号' bindinput='bindPhoneInput'/> \r\n  </view>\r\n  <view class='row'>\r\n     <input placeholder='请输验证码' bindinput='bindCodeInput' style='width:70%;'/> \r\n     <button class='codeBtn' bindtap='getCode' hidden='{{hidden}}' disabled='{{btnDisabled}}'>{{btnValue}}</button>\r\n  </view>\r\n  <view>\r\n     <button class='save' bindtap='save' >保存</button>\r\n  </view>\r\n  \r\n</view>\r\nindex.js//index.js\r\nvar zhenzisms = require('../../utils/zhenzisms.js');\r\n//获取应用实例\r\nconst app = getApp();\r\n \r\nPage({\r\n  data: {\r\n    hidden: true,\r\n    btnValue:'',\r\n    btnDisabled:false,\r\n    name: '',\r\n    phone: '',\r\n    code: '',\r\n    second: 60\r\n  },\r\n  onLoad: function () {\r\n    \r\n  },\r\n  //姓名输入\r\n  bindNameInput(e) {\r\n    this.setData({\r\n      name: e.detail.value\r\n    })\r\n  },\r\n  //手机号输入\r\n  bindPhoneInput(e) {\r\n    console.log(e.detail.value);\r\n    var val = e.detail.value;\r\n    this.setData({\r\n      phone: val\r\n    })\r\n    if(val != ''){\r\n      this.setData({\r\n        hidden: false,\r\n        btnValue: '获取验证码'\r\n      })\r\n    }else{\r\n      this.setData({\r\n        hidden: true\r\n      })\r\n    }\r\n  },\r\n  //验证码输入\r\n  bindCodeInput(e) {\r\n    this.setData({\r\n      code: e.detail.value\r\n    })\r\n  },\r\n  //获取短信验证码\r\n  getCode(e) {\r\n    console.log('获取验证码');\r\n    var that = this;\r\n    zhenzisms.client.init('https://sms_developer.zhenzikj.com', 'appId', 'appSecret');\r\n    zhenzisms.client.send(function (res) {\r\n      if(res.data.code == 0){\r\n        that.timer();\r\n        return ;\r\n      }\r\n      wx.showToast({\r\n        title: res.data.data,\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n    }, '15801636347', '验证码为:3322');\r\n    \r\n  },\r\n  timer: function () {\r\n    let promise = new Promise((resolve, reject) => {\r\n      let setTimer = setInterval(\r\n        () => {\r\n          var second = this.data.second - 1;\r\n          this.setData({\r\n            second: second,\r\n            btnValue: second+'秒',\r\n            btnDisabled: true\r\n          })\r\n          if (this.data.second <= 0) {\r\n            this.setData({\r\n              second: 60,\r\n              btnValue: '获取验证码',\r\n              btnDisabled: false\r\n            })\r\n            resolve(setTimer)\r\n          }\r\n        }\r\n        , 1000)\r\n    })\r\n    promise.then((setTimer) => {\r\n      clearInterval(setTimer)\r\n    })\r\n  },\r\n  //保存\r\n  save(e) {\r\n    console.log('姓名: ' + this.data.name);\r\n    console.log('手机号: ' + this.data.phone);\r\n    console.log('验证码: ' + this.data.code);\r\n \r\n     //省略提交过程\r\n  }\r\n})\r\nindex.wxss/**index.wxss**/\r\npage{\r\n  height: 100%;\r\n  width: 100%;\r\n  background: linear-gradient(#5681d7, #486ec3);\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.container{\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-around;\r\n  width: 90%;\r\n  margin: 50rpx auto;\r\n}\r\n \r\n.row{\r\n  position: relative;\r\n  height: 80rpx;\r\n  width: 100%;\r\n  border-radius: 10rpx;\r\n  background: #fff;\r\n  margin-bottom: 20rpx;\r\n  padding-left: 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n.row input{\r\n  width: 100%;\r\n  height:100%;\r\n}\r\n.codeBtn{\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  color: #bbb;\r\n  width: 30%;\r\n  font-size: 26rpx;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}\r\n.subBtn{\r\n  width: 200rpx;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  color: #000;\r\n  border-radius: 50rpx;\r\n  line-height: 80rpx;\r\n}\r\n完整下载: 下载详情参考: http://smsow.zhenzikj.com/doc..."}
{"title": "在小程序中使用 React with Hooks ", "author": "Rolan", "pub_time": "2019-1-15 00:11", "content": "介绍一下 RemaxRemax 是一个跨多端小程序 React 开发方案，之所以称其为“方案”而非框架是因为这并非一个新的框架，其主要能力就是让 React 能够直接运行在 微信小程序/支付宝小程序/字节跳动小程序/H5（当然这个本来就支持） 等环境。可能会有人要会问 “React 不是早就可以运行在小程序中了么“？本文会介绍一下现如今的一些小程序框架的解决方案，以及为什么我们认为把 React 直接搬进小程序是个更为合理的方案。静态编译类框架由于大多开发者都更熟悉 React 和 Vue 的 API 和语法，加上小程序本身的开发方式确实让人痛苦，于是便有了一些框架来将这些熟悉的语法编译到小程序的 WXML/WXSS/JS 上，其中比较具有代表性的例如 taro，其目标就是让开发者能够用 React 的开发方式编写小程序。而这类框架的实现原理其实并非真的是一个 React 或者类 React 框架，而是把看起来像是 JSX 的模板通过静态编译的方式翻译成小程序自身的模板。这样做的限制非常明显，那就是 JSX 是 JavaScript 的拓展语言（React Blog 写的是 is a syntax extension to JavaScript），而小程序所采用的 WXML 却是一个表达能力非常受限的模板语言，我们不可能完成从一个通用编程语言到模板语言的编译。而静态编译类框架为了做到这一点，采取的方式就是限制开发者的写法，这也是为什么上面称之为看起来像是 JSX 的模板，这也是为什么 taro 对 JSX 的写法做出了诸多限制。这种方案大多声称这些限制并没有限制生产力，或者符合最佳实践等等。然而我们其实都知道这是由于小程序本身的坑造成的，静态编译方案编译的永远都只会是模板语言，而不是 JSX。React Hooks之所以我说这些限制并非基于最佳实践，是因为 React 本身对于 JSX 的定位就 并非模板。JSX is a syntax extension to JavaScript.在最近 React 团队已经向我们介绍了 Hooks，期望可以 functional component 不仅仅可以是无状态组件，也可以是 useState 的。import { useState } from 'react';\r\n\r\nfunction Example() {\r\n  // Declare a new state variable, which we'll call \"count\"\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\nReact 官方博客提到 Classes confuse both people and machines，我们也明显可以看到基于 function 的组件明显更为简洁，噪声更小，未来 React 社区的方向更是会逐渐从 class component 过渡到 functional component。在这种趋势下，把 JSX 当做模板写，且未来永远也不可能支持 functional component 的方案绝非真的基于最佳实践的选择。在 Remax 中，我们完全可以使用全新的 Hooks API 来开发组件因为 Remax 中的 React 就是 React.js，而 JSX 就是 JavaScript 的超集。上图中使用小程序的原生语法，classname 和 inline style 就只能写成<view class=\"weui-navbar__item {{activeIndex == index ? 'weui-bar__item_on' : ''}}\">\r\n</view>\r\n<view style=\"left: {{sliderLeft}}px; transform: translateX({{sliderOffset}}px); -webkit-transform: translateX({{sliderOffset}}px);\"></view>\r\n而使用 remax 后就可以写成正常的 react：const innerStyle = {\r\n    left: `${sliderLeft}px`,\r\n    transform: `translateX(${sliderOffset}px);`,\r\n    '-webkit-transform': `translateX(${sliderOffset}px)`,\r\n    width: sliderWidth,\r\n  };\r\nconst itemClassName = classnames({\r\n   'weui-navbar__item': true,\r\n    'weui-bar__item_on': activeIndex === index,\r\n});\r\n\r\nreturn <View className={itemClassName}>\r\n    <View style={innerStyle} />\r\n    </View>\r\n实现原理核心部分Remax 的实现原理和基于静态编译的方案有所不同，其核心其实是重新实现了 ReactDOM 的部分。众所周知，React 本身的设计就是支持跨端渲染的，render 部分和 React 的核心逻辑是解耦的（甚至不在一个 npm 包里）。主要的 render 有 ReactDOM（浏览器），ReactDOMServer（服务器端）和 ReactNative。Remax 要做的事情和 ReactNative 要做的事情非常类似，我们重新接管了 ReactDOM 的 render。在原有的 React 页面中，React 在完成 Diff 发现需要修改界面时，又 ReactDOM 把改变 Patch 到页面上。而在小程序中由于我们不能直接修改页面，则由 React 完成 DIFF 后由 Remax 把修改 Patch 到内存中的虚拟 DOM 上，然后再通过小程序自己的虚拟 DOM 最后把改变同步到页面上。在这里我把这个过程说得非常简单，但实际上是有些坑要填的，主要也都是来自于小程序的限制，后续会有新的文章展开来讲。但是这种实现方式使得我们完全可以把 React 的代码放在小程序的环境中运行。工程化工程化很理所当然的用 Webpack 来实现， 除了我们常用的打包等功能外，Webpack 插件也使我们很容易构建一些我们需要的东西出来，例如我们需要在每个 js 入口除了放一个 js 外还需要添加一个 wxml 文件，就可以通过一个很简单的 Webpack 插件来实现。function GeneraeWxmlWebpackPlugin() {\r\n  const content = `<view>...</view>`;\r\n  const apply = (compiler) => {\r\n    const emit = (compilation, cb) => {\r\n      const {\r\n        chunks,\r\n      } = compilation;\r\n      chunks.forEach((item) => {\r\n        compilation.assets[`${item.name}.wxml`] = {\r\n          source: () => content,\r\n          size: () => content.length,\r\n        };\r\n      });\r\n\r\n      cb();\r\n    };\r\n\r\n    if (compiler.hooks) {\r\n      const plugin = { name: 'GeneraeWxmlWebpackPlugin' };\r\n      compiler.hooks.emit.tapAsync(plugin, emit);\r\n    } else {\r\n      compiler.plugin('emit', emit);\r\n    }\r\n  };\r\n\r\n  return {\r\n    apply,\r\n  };\r\n}\r\n跨端这种方案想实现同一套代码跨到 H5 端显然没有什么问题，至于支付宝小程序目前验证了一下可行性也是可行的。项目结构这个项目主要由几块组成@remax/core核心部分，负责 React 组件的 render@remax/cli顾名思义，CLI 工具，用于构建生成相应的小程序项目等工作@remax/components底层 Component，包括诸如 View 等一些基础组件，用于抹平不同环境的差异@remax/ui自带的基础组件库，这部分还待开发，目前只有一两个示例组件由于目前整个项目才刚刚起步，暂时还不能用于生产环境，目前的几个主要开发者（和打算参与的）有 @CodeFalling @bramblex @ahonn @SimplyY目前的 DEMO 可以扫码体验：或者在可以按照 https://github.com/CodeFalling/remax#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B 体验本地 DEMO。如果有人想要参与进来一起开发可以联系我，开发相关的细节文档会陆续更新在 https://github.com/CodeFalling/remax/wiki/%E5%85%A5%E9%97%A8 。讨论群@remax/dev推荐阅读https://reactjs.org/docs/introducing-jsx.htmlhttps://reactjs.org/docs/hooks-intro.htmlReact v16.7 \"Hooks\" - What to Expect"}
{"title": "微信小程序复选框实现 多选一功能 ", "author": "Rolan", "pub_time": "2019-1-24 00:32", "content": "功能实现界面data: {\r\n    checkboxItems: [\r\n      { name: '全天(1-8节)', value: 'allday' },\r\n      { name: '上午(1-4节)', value: 'am' },\r\n      { name: '下午(5-8节)', value: 'pm' },\r\n      { name: '晚上(晚自习)', value: 'night' },\r\n    ]\r\n  }  想要实现的功能 四个复选框中只能选一个，且选中另一个会取消其余选中,且能保存选择的value值JS代码实现checkboxChange: function (e) {\r\n    var that = this;\r\n    let checkboxValues=null;\r\n    let checkboxItems = this.data.checkboxItems, values = e.detail.value\r\n    for (var i = 0, lenI = checkboxItems.length; i < lenI; ++i) {\r\n      if(checkboxItems[i].value==values[values.length-1]){\r\n        checkboxItems[i].checked=true;\r\n        checkboxValues = checkboxItems[i].value;\r\n      }\r\n      else{\r\n        checkboxItems[i].checked = false;\r\n      }\r\n    }\r\n    console.log(checkboxValues)\r\n    that.setData({ checkboxItems, checkboxValues })\r\n  }  前端代码 <view class=\"weui-cells weui-cells_after-title\">\r\n      <checkbox-group class=\"weui-flex\" bindchange=\"checkboxChange\">\r\n        <label class=\"weui-cell weui-check__label weui-flex__item\" wx:for=\"{{checkboxItems}}\" wx:key=\"value\">\r\n          <checkbox class=\"weui-check\" value=\"{{item.value}}\" checked=\"{{item.checked}}\" />\r\n          <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n            <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\" wx:if=\"{{item.checked}}\"></icon>\r\n          </view>\r\n          <view class=\"weui-cell__bd\">{{item.name}}</view>\r\n        </label>\r\n      </checkbox-group>\r\n    </view>对应的CSS样式是WeUI"}
{"title": "用vue重构小程序踩坑之旅(1) --- 微信sdk验签 ", "author": "Rolan", "pub_time": "2019-2-14 00:15", "content": "问题:验签失败　　惨景:用微信sdk实现h5页面的分享,且每个页面分享内容需要自定义.坑1:在Android和ios的系统中,同一个页面Android验签成功,ios验签失败解决方案:因为在使用vue的router时 ios复制出来的页面地址永远都是xxxx.com 而Android系统则是xxx.com/index,这就是照成验签失败的原因;　　查阅解决方案:　　https://www.jianshu.com/p/a470403de789　　大佬写的很详细坑2:某一页面Android验签失败,ios验签成功; --- 脑壳疼解决方案:　　在填埋了坑1后,ios就基本不用考虑单页面验签,但是在某页面中发现Android 验签失败,查出原因是因为url中拼接了中文的埋点.(做小程序跳转时 一般都会加到query中)　　vue中是会把query拼接到url上.建议吧这些数据后期用vuex来保存,(emmm,vue菜鸟,没测过此方案)　 invalid signature签名错误坑3:调用微信sdk的分享接口时,ios成功分享,Android分享失败解决方案(应急解决):　　微信jssdk 1.4使用新的2个分享接口: wx.updateAppMessageShareData 和 wx.updateTimelineShareData 不知道为什么 用了新的接口后就会产生以上问题,所以目前解决方案就是　　用旧的接口wx.onMenuShareTimeline(即将废弃);---脑壳又疼了"}
{"title": "小程序 setData 为什么不能频繁设置 ", "author": "Rolan", "pub_time": "2019-2-20 00:25", "content": "先科普下 setData 做的事情：在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。因此频繁调用，视图会一直更新，阻塞用户交互，引发性能问题。但频繁调用是常见开发场景，能不能频繁调用的同时，视图延迟更新呢？参考 Vue，我们能知道，Vue 每次赋值操作并不会直接更新视图，而是缓存到一个数据更新队列中，异步更新，再触发渲染，此时多次赋值，也只会渲染一次。于是有网友就给出了这套方案的实现方法：let newState = null\r\nconst asyncSetData = ({\r\n    vm,\r\n    newData,\r\n}) => {\r\n    newState = {\r\n        ...newState,\r\n        ...newData,\r\n    }\r\n    Promise.resolve().then(() => {\r\n        if (!newState) return\r\n        vm.setData({\r\n            ...newState,\r\n        })\r\n        newState = null\r\n    })\r\n}由于 异步代码会在同步代码执行完后执行 ，因此多次 asyncSetData 的 newData 都会缓存在 newState 中，并在异步的 promise.then 中只 setData 一次。但这个方案会带来新的问题：就是 同步代码会阻塞页面的渲染 。同步代码会阻塞页面的渲染的问题其实在浏览器中也存在，但在小程序中，由于是逻辑、视图双线程架构，因此逻辑并不会阻塞视图渲染，这是小程序的优点，但在这套方案将会丢失这个优点。鱼与熊掌不可兼得也！参考资料终极蛇皮上帝视角之微信小程序之告别 setData , 佯真愚, 2018年08月12日"}
{"title": "小程序开发-数据请求层的封装 ", "author": "Rolan", "pub_time": "2019-2-26 00:46", "content": "许久不曾写博客文章，今日回归，再次拾起，不以用来予人参考，只为记录那些曾经在项目里面碰到过的实际问题以及解决办法，记录下来，以后可以用作参考。回归正题在小程序开发中，我们请求后台数据接口的时候，屡次要使用小程序的网络请求api函数 wx.request ，然后就是一大段的代码与回调函数，非常的不方便代码复用和代码的维护检查， 因此，我们尝试来封装一个“数据请求层”。1、新建一个专门用于放置与接口请求有关的js文件，并命名为 “api” 不多bb，把代码贴上如图。文件夹内容2、在index.js里面封装wxRequest，封装成为Promise的形式，用于在其他js文件调用。const baseUrl = \"www.baidu.com\"; //这里以百度为例子，可自行修改接口地址//通用方法const wxRequest = (url, method, params) => {  return new Promise((resolve, reject) => {    wx.request({      url: `${baseUrl}${url}`,      data: params,      method: method,      header: {        'wili-access-token': wx.getStorageSync('token'),      },      success: res => {        if (res.statusCode === 200) {          resolve(res);        } else {          reject(res);        }      },      error: error => {        reject(error);      }    });  }).catch(msg => {    console.error(msg);  });};module.exports.wxRequest = wxRequest;代码的意思是 把 url, method, params 这些会发生变化的作为参数传入。如果请求成功则会调用resolve(res); 并把返回信息res传入，如果失败则会调用 reject(error)方法;并把错误信息传入。 最后把wxRequest变量导出，因为小程序遵循的模块化方案使用的是commonJS的方案。3、调用请求方法 举个栗子，我们在api_user.js 这个文件内调用刚刚封装好的wxRequest ，如图。const api = require('./index.js');//  用户相关apimodule.exports.login = params => {  return api.wxRequest('/api/getMiniUserInfo', 'POST', params)}// module.exports.saveUserInfo = params => {//   return api.wxRequest('/api/miniRegist', 'POST', params)// }module.exports.getUserInfo = params => {  return api.wxRequest('/api/personal', 'GET', params)}导入我们刚刚封装好的index.js文件模块，由于我们刚刚封装的是Promise形式的wxRequest ，所以函数的返回值返回的就是Promise对象，例如， return api.wxRequest('/api/getMiniUserInfo', 'POST', params) 这里就是传递请求参数，当请求成功后会返回wxRequest 的一个Promise“结果”对象， 这个结果对象由 resolve方法 或者reject方法执行后返回的。(不理解Promise的童鞋，可自行先理解学习一下ES6 Promise)。4、使用封装好的处理数据的apiconst { login, getUserInfo } = require(\"./api/api_user.js\");App({  onLaunch: function() {    // 登录    wx.login({      success: res => {        this.userLogin(res.code);      }    });  },  // 小程序启动请求登录接口  userLogin(code) {    login({ code }).then(res => {//调用的login就是我们上面封装好的哈      wx.setStorageSync(\"token\", res.data.data);    });  },  globalData: {    userInfo: null  }});引入api_user.js ，在userLogin函数里面执行的login函数，就是我们刚刚经过封装用作处理接口数据的函数了。传入它的参数。在then()里面拿到返回的数据res与执行回调函数处理之后逻辑。"}
{"title": "微信小程序 关于父子组件一些心得 ", "author": "Rolan", "pub_time": "2019-3-5 00:46", "content": "父子组件样式的设置\r\n1、 如何对父子组件设置flex布局\r\n如果在小程序中对父组件设置 display:flex 或者 display:inline-flex 然后再对子组件最外层元素的class设置flex的样式属性会发现不会有效果。\r\n比如在这个截图中\r\n\r\n父元素 .parent-box 是 display:flex 然后对子元素 .child-box 设置  flex、justify-content、align-content 等属性会发现都没有效果。\r\n我们看截图可以发现其实微信小程序渲染完后会对组件里面的内容再套一层组件名称的标签。所以如果要对子元素设置flex属性的话应该对子元素使用小程序提供的:host选择器。\r\n父元素样式\r\n.parent-box{\r\n    display:flex;\r\n}\r\n复制代码子元素样式\r\n:host{\r\n    flex: 1;\r\n}\r\n复制代码2、根据不同条件渲染子组件根节点的样式\r\n比如组件在某些特殊场景不使用flex布局而是采用其他方式布局，我们希望同过某种方式来控制子组件根节点的样式。但是微信小程序的:host选择器似乎没法做到这种需求。如果后面微信小程序的:host选择器可以支持属性选择器也许可以做到。\r\n这里没有找到特别好的办法,这里我说下两种比较差的解决方法\r\n· 在小程序自定义组件标签其实相对于view标签或者text标签可以直接在标签中使用style或者class的。就是利用标签的style或者class动态去改变。\r\n<parent>\r\n    <child \r\n        class=\"{{ childStyle == 1 ? child-style-1 : child-style-2 }}\"\r\n        style=\"{{ childStyle == 1 'background:red;':'background:blue' }}\" >\r\n    </child>\r\n</parent>\r\n复制代码这里尝试过在父组件和子组件去设置子组件的class都是没有反应的，所以子组件class只能在Page的Wxss中去设置。\r\n· 一种就是如果明确了子组件的标签名称我们可以在父组件的样式中去设置不同的子组件样式\r\n父元素样式\r\n.parent{\r\n    display:flex;\r\n}\r\n.parent-box child{\r\n    flex:1;\r\n}\r\n.parent-box.column child{\r\n    flex-direction: column;\r\n}\r\n.parent-box.row child{\r\n    flex-direction: row;\r\n}\r\n复制代码不过这种方式也不太好，因为组件的是在Page的json可以随意命名的，这种方法除非是团队开发开始个人约定好了组件的名称，不会随意给组件起名的情况下。\r\n这种方法甚至可以用CSS的选择器控制某一个子组件单独的样式\r\n父元素样式\r\n.parent-box child:first-child{\r\n    flex:1;\r\n}\r\n复制代码父元素获取子元素WMXL\r\n有些时候为了一些组件的扩展性我们会把他们拆成父子组件，又有些时候组件内有一些需要酷炫的样式动画我们可能需要在父组件内拿到子组件的节点信息去进行计算。这里我说下我用的方法。\r\n1、使用 wx.createSelectorQuery().in()\r\n在linked生命周期时会传递过来子组件的实例对象，在这个使用把wx.createSelectorQuery().in传入子组件包装成Promise插入数组。待要获取子元素们的节点信息时调用。\r\n父组件JS\r\nComponent({\r\n       data: {\r\n           childRectPromises:[]\r\n       },\r\n       relations: {\r\n           '/child': {\r\n               type: 'child',\r\n               linked(v) {\r\n                   const p = ()=> new Promise((resolve,reject)=>{\r\n                       const query = wx.createSelectorQuery().in(v)\r\n                       query.select('.child-box').boundingClientRect(function(res){\r\n                           resolve(res)\r\n                       }).exec()\r\n                   })\r\n                   this.data.childRectPromises.push(p);\r\n               },\r\n           }\r\n       },\r\n       ready(){\r\n           Promise.all(this.data.childRectPromises.map(p=>p())).then(res=>{\r\n               /* 逻辑 */\r\n           })\r\n       }\r\n})\r\n复制代码2、使用 >>> 选择器\r\n如果用上面的方法如果有10个子元素，我们就要调用10次的 wx.createSelectorQuery().in().select()。怎么都感觉十分的消耗性能，如果可以使用selectAll一次性把全部子元素的节点信息给拿到就好了。这时我们就想可以不可以\r\n   wx.createSelectorQuery().in(父元素对象).selectAll(子元素节点)\r\n复制代码\r\n经过我的测试，在组件已经渲染完毕有子元素的情况下，返回的是个空数组，说明这种写法是不行的。哪还有什么办法呢。\r\n其实在微信小程序中 在selectAll/select中 提供了 >>> 这样一个选择器，这个选择器可以在拿到页面组件中对匹配到的节点。\r\n我们只要 wx.createSelectorQuery().selectAll( 父组件 >>> 子元素节点 ) 像这么写我们就可以一次轻松拿到全部子节点啦。\r\n但是这里我们这么写 wx.createSelectorQuery().selectAll( 父组件元素class >>> 子元素节点 )是没有作用的，我的理解是，因为我们没有在wx.createSelectorQuery()调用in方法就是相当于在Page中查找这些元素，而不是在组件内，父组件元素class是封装在组件内的所以查找不到这个元素，也就返回了空数组。\r\n相对于页面，如果我们用组件的标签名，就如上面所说的组件名可以随意起名并不是很合适，这时我们就想要是知道父组件的某个class或者id就好了，知道父组件设置了什么class可能可能不太显示，不过如果我们对标签设置了id我们确可以从this从获取到。\r\n这时我们成功只用一次selectAll获取到了父组件的子元素们。不过这么做有个缺点就是一定要设置id才行,不过为了性能优化我们可以从在父组件中做个判断如果id为空则提示使用此组件需要设置id。\r\n好了以上就是我在开发小程序中对父子组件的一些心得，如果大家有一些更好的办法或者心得希望可以与我分享，谢谢各位。"}
{"title": "微信小程序页面返回优化 ", "author": "Rolan", "pub_time": "2019-3-6 00:23", "content": "页面栈微信小程序的路由历史，用一个栈来管理，这个栈最多累积10层（以前是最多5层，小程序的api说变就变！）。场景：一个学生信息列表，当需要修改信息时跳转到修改页面。每修改一个学生信息就需要跳转一次页面。同时又需要保留修改页面，而不是每次销毁它。这时候用wx.navigateTo，wx.redirectTo，显然是不满足的。同时用wx.redirectTo返回页面也会出现中间历史页面闪现一下的问题。解决办法：wx.navigateBack(Object object)关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。自己封装返回路由："}
{"title": "微信小程序端用户授权处理 ", "author": "Rolan", "pub_time": "2019-3-6 00:32", "content": "taro1.安装 tarojsnpm install -g @tarojs/cli2.初始化项目taro init taro-login3.进入目录cd taro-login4.运行编译npm run dev:weapp5.修改文件 /src/app.js 代码...\r\n\r\nclass App extends Component {\r\n\r\n  config = {\r\n    pages: [\r\n      'pages/user/user', // new\r\n      'pages/index/index',\r\n    ],6.微信登录需求如果我们需要用户一进入就取得用户的授权，以便于进行某些记录用户信息的操作，而微信又要求用户去点页面上的某个按钮才能获取信息，那怎么办呢？只能把一个按钮放在用户不能不点的地方，那就只有弹窗了。微信 wx.showModal 不能满足我们的需求，只能自己造一个，在用户第一次进来的时候弹窗，再次进来的时候则不显示。为了让这个组件具有拓展性，我们根据传入的值来修改 确认 位置按钮的属性，如果是授权的弹窗就改按钮属性为 openType='getUserInfo'。(摘自 Taro 多端开发实现原理与项目实战 )7.新建文件夹和modal.js文件 /src/components/modal/modal.jsimport Taro, { Component } from '@tarojs/taro'\r\nimport { View, Button } from '@tarojs/components'\r\n\r\nimport './modal.scss'\r\n\r\nclass Modal extends Component {\r\n  constructor() {\r\n    super(...arguments)\r\n    this.state = {}\r\n  }\r\n\r\n  onConfirmClick = () => {\r\n    this.props.onConfirmCallback()\r\n  }\r\n\r\n  onCancelClick = () => {\r\n    this.props.onCancelCallback()\r\n  }\r\n\r\n  onAuthConfirmClick = (e) => {\r\n    this.props.onConfirmCallback(e.detail)\r\n  }\r\n\r\n  preventTouchMove = (e) => {\r\n    e.stopPropagation()\r\n  }\r\n\r\n  render() {\r\n    const { title, contentText, cancelText, confirmText, isAuth } = this.props\r\n    return (\r\n      <View className='toplife_modal' onTouchMove={this.preventTouchMove}>\r\n        <View className='toplife_modal_content'>\r\n          <View className='toplife_modal_title'>{title}</View>\r\n          <View className='toplife_modal_text'>{contentText}</View>\r\n          <View className='toplife_modal_btn'>\r\n            <Button className='toplife_modal_btn_cancel' onClick={this.onCancelClick}>{cancelText}</Button>\r\n            {!isAuth ?\r\n              <Button className='toplife_modal_btn_confirm' onClick={this.onConfirmClick}>{confirmText}</Button> :\r\n              <Button className='toplife_modal_btn_confirm' openType='getUserInfo' onGetUserInfo={this.onAuthConfirmClick}>授权</Button>}\r\n          </View>\r\n        </View>\r\n      </View>\r\n    )\r\n  }\r\n}\r\n\r\nModal.defaultProps = {\r\n  title: '',\r\n  contentText: '',\r\n  cancelText: '取消',\r\n  confirmText: '确定',\r\n  isAuth: false,\r\n  onCancelCallback: () => { },\r\n  onConfirmCallback: () => { }\r\n}\r\n\r\nexport default ModalModal 组件还算比较简单，组件的属性：字段说明title提示的标题contentText提示的描述cancelText取消按钮的文案cancelCallback取消回调的函数confirmText确认按钮的文案confirmCallback确认回调函数isAuth标记是否为授权按钮在内部设置了一个函数 preventTouchMove ，其作用是弹窗出现蒙层的时候，阻止在蒙版上的滑动手势 onTouchMove 。另外一个函数 authConfirmClick ， 当 isAuth 为真时，确认按钮为取得个人信息的授权按钮，此时把个人信息当值传递给调用的函数。(摘自 Taro 多端开发实现原理与项目实战 )8.添加 modal.scss 文件/*postcss-pxtransform rn eject enable*/\r\n\r\n.toplife_modal {\r\n  position: fixed;\r\n  width: 100%;\r\n  height: 100%;\r\n  left: 0;\r\n  top: 0;\r\n  background-color: rgba(0, 0, 0, .8);\r\n  z-index: 100;\r\n\r\n  &_content {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    width: 600px;\r\n    height: 320px;\r\n    transform: translate(-50%, -50%);\r\n    background-color: #fff;\r\n    color: #232321;\r\n    text-align: center;\r\n    border-radius: 30px;\r\n  }\r\n\r\n  &_title {\r\n    margin-top: 40px;\r\n    font-size: 32px;\r\n  }\r\n\r\n  &_text {\r\n    margin-top: 40px;\r\n    font-size: 24px;\r\n  }\r\n\r\n  &_btn {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 88px;\r\n    border-top: 2px solid #eee;\r\n\r\n    &_cancel {\r\n      color: #8c8c8c;\r\n      border-radius: 0;\r\n      border: 0;\r\n      border-right: 2px solid #eee;\r\n      border-bottom-left-radius: 30px;\r\n    }\r\n\r\n    &_confirm {\r\n      color: #666;\r\n      border-radius: 0;\r\n      border: 0;\r\n      border-bottom-right-radius: 30px;\r\n    }\r\n\r\n    button {\r\n      display: block;\r\n      float: left;\r\n      width: 50%;\r\n      height: 88px;\r\n      text-align: center;\r\n      line-height: 88px;\r\n      font-size: 32px;\r\n      box-sizing: border-box;\r\n      background-color: #fff;\r\n\r\n      &::after {\r\n        border: 0;\r\n      }\r\n    }\r\n  }\r\n}9.新建文件 /src/page/user/user.js ,在 user.js 中引用该 Modal 组件import Taro, { Component } from '@tarojs/taro';\r\nimport { View, Image, Text } from '@tarojs/components';\r\nimport classnames from 'classnames'\r\nimport Modal from '../../components/modal/modal';\r\nimport { setGlobalData } from '../../utils/globalData';\r\nimport { getUserInfo, getIsAuth } from '../../utils/getUser';\r\n\r\n\r\nclass Info extends Component {\r\n  config = {\r\n    navigationBarTitleText: 'TARO商城',\r\n    enablePullDownRefresh: true,\r\n    backgroundTextStyle: 'dark',\r\n    disableScroll: true\r\n  }\r\n\r\n  constructor() {\r\n    super(...arguments)\r\n    this.state = {\r\n      animationClass: '',\r\n      showAuthModal: false,\r\n      shouldIndexHidden: false,\r\n    }\r\n    this.env = process.env.TARO_ENV\r\n  }\r\n  hideAuthModal() {\r\n    this.setState({\r\n      showAuthModal: false\r\n    })\r\n    Taro.setStorage({ key: 'isHomeLongHideAuthModal', data: true })\r\n  }\r\n\r\n  onProcessAuthResult = (userData) => {\r\n    Taro.setStorage({ key: 'isHomeLongHideAuthModal', data: true })\r\n    if (userData.userInfo) {\r\n      setGlobalData('userData', userData)\r\n    }\r\n    this.setState({\r\n      showAuthModal: false\r\n    })\r\n    getIsAuth()\r\n  }\r\n\r\n  async onPullDownRefresh() {\r\n    if (this.state.shouldIndexHidden) {\r\n      Taro.stopPullDownRefresh() // 停止下拉刷新\r\n    } else {\r\n      await this.props.onFetchIndexList()\r\n      Taro.stopPullDownRefresh() // 停止下拉刷新\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    if (this.env === 'weapp') {\r\n      // 用类名来控制动画\r\n      setTimeout(async () => {\r\n        const userData = await getUserInfo();\r\n        Taro.getStorage({\r\n          key: 'isHomeLongHideAuthModal',\r\n          success: (res) => {\r\n            const isHomeLongHideAuthModal = res.data;\r\n            let showAuthModal\r\n            if (!userData && !this.state.showAuthModal && !isHomeLongHideAuthModal) {\r\n              showAuthModal = true\r\n            } else {\r\n              showAuthModal = false\r\n            }\r\n            this.setState({\r\n              animationClass: 'animation',\r\n              showAuthModal\r\n            })\r\n          },\r\n          fail: () => {\r\n            let showAuthModal\r\n            if (!userData && !this.state.showAuthModal) {\r\n              showAuthModal = true\r\n            } else {\r\n              showAuthModal = false\r\n            }\r\n            this.setState({\r\n              animationClass: 'animation',\r\n              showAuthModal\r\n            })\r\n          }\r\n        })\r\n      }, 1000)\r\n      getIsAuth()\r\n    } else if (this.env === 'h5' || this.env === 'rn') {\r\n      console.log('h5登录')\r\n    }\r\n  }\r\n  render() {\r\n    const { animationClass, shouldIndexHidden, showAuthModal } = this.state\r\n    const { loginname, avatar_url } = this.props;\r\n    const indexClassNames = classnames('container', 'index', animationClass, {\r\n      hidden: shouldIndexHidden\r\n    })\r\n    return (\r\n      <View className={indexClassNames}>\r\n        <View className='login-head'>\r\n          <Image className='login-head-back'\r\n            src={require('../../assets/img/loginBack.jpg')}\r\n          />\r\n          <Image className='login-head-head'\r\n            src={avatar_url ? avatar_url : require('../../assets/img/head.png')}\r\n          />\r\n          {loginname ? <Text classnames='login-head-name'>{loginname}</Text> : null}\r\n        </View>\r\n        {showAuthModal && <Modal\r\n          title='授权提示'\r\n          contentText='诚邀您完成授权，尊享畅游体验'\r\n          onCancelCallback={this.hideAuthModal.bind(this)}\r\n          onConfirmCallback={this.onProcessAuthResult.bind(this)}\r\n          isAuth\r\n        />}\r\n      </View>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Info我们是如何保证这个应用只有一次授权弹窗呢？ 关键代码是 Taro.setStorageSync('isHomeLongHideAuthModal', true) ，如果弹出了一次，就在本地存一个标记已经弹过授权框，下一次弹窗之前可以根据此判断。至此我们完成了授权处理，但如果可以的话还是要优雅一些，在需要的时候才征求用户授权，保证用户体验。(摘自 Taro 多端开发实现原理与项目实战 )10.新建几个辅助文件/src/utils/globalData.jsconst globalData = {}\r\n\r\nexport function setGlobalData(key, val) {\r\n  globalData[key] = val\r\n}\r\n\r\nexport function getGlobalData(key) {\r\n  return globalData[key]\r\n}/src/utils/request.jsimport Taro from '@tarojs/taro';\r\nimport '@tarojs/async-await';\r\n\r\nexport function getJSON(url, data) {\r\n  Taro.showLoading();\r\n  return Taro.request({ url: url, data: data, method: 'GET' }).then(result => {\r\n    Taro.hideLoading();\r\n    return result;\r\n  })\r\n}\r\n\r\nexport function postJSON(url, data) {\r\n  Taro.showLoading()\r\n  return Taro.request({\r\n    header: { 'content-type': 'application/json' },\r\n    url: url,\r\n    data: data,\r\n    method: 'POST'\r\n  }).then(result => {\r\n    Taro.hideLoading();\r\n    return result;\r\n  });\r\n\r\n}/src/constants/apiconst rootPath = 'http://127.0.0.1:5000/v1';\r\nconst apiObject = {\r\n  registerclient: rootPath + '/client/register', //注册用户\r\n  getusertoken: rootPath + '/token', // 登录成功之后获取用户token\r\n  checkusertoken: rootPath + '/token/secret', //验证用户token\r\n  getuserinfo: rootPath + '/user', //获取用户信息\r\n}\r\nexport default apiObject;11. 新建一个登录获取token的函数/src/utils/getUser.jsimport Taro from '@tarojs/taro'\r\nimport { getGlobalData } from './globalData'\r\nimport api from '../constants/api';\r\nimport { postJSON } from '../utils/request';\r\n\r\n\r\nasync function getUserInfo() {\r\n  const userData = getGlobalData('userData')\r\n  if (userData) {\r\n    return userData\r\n  }\r\n  try {\r\n    const _userData = await Taro.getUserInfo()\r\n    return _userData\r\n  } catch (err) {\r\n    console.log(err)\r\n    console.log('微信登录或用户接口故障')\r\n    return null\r\n  }\r\n}\r\n\r\nasync function getIsAuth() {\r\n  const loginRes = await Taro.login()\r\n  let { userInfo } = await getUserInfo()\r\n  let isAuth = false\r\n  if (userInfo) {\r\n\r\n    // 使用微信注册新用户\r\n    let result = await postJSON(api.registerclient, {\r\n      \"avatar\": userInfo.avatarUrl,\r\n      \"sex\": userInfo.gender,\r\n      \"nickname\": userInfo.nickName,\r\n      \"account\": loginRes.code,\r\n      \"type\": 200\r\n    });\r\n    if (result.data.error_code == 0) {\r\n\r\n      // 登录用户，获取token,缓存到前端\r\n      const tokenRes = await Taro.login()\r\n      let auth_token = await postJSON(api.getusertoken, {\r\n        \"account\": tokenRes.code,\r\n        \"type\": 200\r\n      })\r\n      if (auth_token.statusCode == 201) {\r\n        Taro.setStorage({ key: 'token', data: auth_token.data.token })// 设置到缓存\r\n        Taro.showToast({ title: '授权成功' })\r\n        userInfo.isAuth = true\r\n        isAuth = true\r\n      }\r\n    } else {\r\n      Taro.showToast({ title: '授权失败，请稍后再试', icon: 'none' })\r\n    }\r\n\r\n  } else {\r\n    userInfo = {\r\n      isAuth: false\r\n    }\r\n  }\r\n  console.log('isAuth: ', isAuth)\r\n  return isAuth\r\n}\r\n\r\nexport {\r\n  getUserInfo,\r\n  getIsAuth\r\n}flask学习资料:慕课网-Python Flask构建可扩展的RESTful API慕课网-掌握Taro多端框架 快速上手小程序/H5开发Taro 多端开发实现原理与项目实战"}
