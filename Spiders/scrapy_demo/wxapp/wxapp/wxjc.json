{"title": "微信小程序开发需要注意的一些规范 ", "author": "Rolan", "pub_time": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"title": "小程序报错 “渲染层错误” Expect END descriptor with depth 0 but get another ... ", "author": "Rolan", "pub_time": "2019-5-10 00:53", "content": "项目中有几个页面在控制台出现这个“渲染层错误”，虽然不影响业务操作，怕存在潜在风险，今天抽时间找了下原因，解决这个问题。控制台报错日志如下：(中国标准时间) 渲染层错误Error: Expect END descriptor with depth 0 but get anotherat i.value (:39360/__pageframe__/__dev__/WAWebview.js:1)at Function.G [as _startCb] (:39360/__pageframe__/__dev__/WAWebview.js:1)at n (:39360/__pageframe__/__dev__/WAWebview.js:1)at h (:39360/__pageframe__/__dev__/WAWebview.js:1)at :39360/__pageframe__/__dev__/WAWebview.js:1at t.(:39360/appservice/anonymous function) (http://127.0.0.1:39360/__pageframe__/__dev__/WAWebview.js:1:94975)at :39360/__pageframe__/pageframe.html:1at :39360/__pageframe__/pageframe.html:1at :39360/__pageframe__/pageframe.html:1at Array.forEach (<anonymous>)截图： 主要找到了2个原因，记录分享一下：1、在js中操作中，把undefined赋值给了一个数组变量，假设变量名为arr;      在.wxml页面中使用了变量arr.       这个原因导致了报“渲染层错误”。处理了arr变量后，这个错误也就没有了 2、子组件的.wxml页面中使用了if造成了这个报错，后面把if判断改成style来控制隐藏显示，     然后也消除了这个“渲染层错误”。   未改前代码截图：改后代码截图：奇怪的是其他地方使用if并没有报这个错，原理还不清楚！"}
{"title": "基于云开发的小程序评论、点赞、收藏功能实现总结 ", "author": "Rolan", "pub_time": "2019-5-13 00:12", "content": "mini-blog 的详情页的功能按钮基本已经全部实现（除了生成海报功能），这里记录下整个实现过程和实际编码中的一些坑。实现思路实现文章的一些操作功能，最主要的还是评论，这是作者和读者之间沟通的桥梁，评论功能的衍生无非是细化作者和读者之间的互动，或者增加文章的传播，所以在动手开发时需要思考下你期望实现哪些功能，并对应功能进行细化。我一般的经验是，先在脑子里过一遍需要的功能和大致流程，然后在笔记稍微画下「最最基础的原型，相当于产品的角色」。然后就开始直接开始搭建页面和简单的交互「使用假数据，优先完成页面」，在构造页面的时候其实也能够补充最初想法上一些流程上的缺陷，这样在设计后端和数据库结构的时候可以补上，整体下来也基本比较完善了。回头看我的小程序的需求，首先肯定是操作，在文章底部需要有个操作栏，用于发送点评和其他一些操作，在参考了一些同类型的小程序之后，逐步实现自己的一套风格，样式截图如下：在有了功能之后，点评的数据需要有地方展示「通常是文章底部」，然后就有了文章底部的评论列表，样式如下：既然有 点赞 和 收藏 的功能按钮，是否用户需要看下我点赞和收藏的文章列表呢，所以在「我的」中就有相应的列表，样式如下：到这里，最最基础的功能基本差不多，接下来就要看后端是否能支持这些页面了「主要就是数据的保存和展示了」对于评论来说，肯定需要一个集合用于保存用户的评论，而对于用户的喜欢和收藏也需要一个集合来进行保存。所以根据页面我们就可以设计 mini_comments 和 mini_posts_related 两个集合。前者用于保存评论数据，后者用户保存用户操作与文章之间的关联。剩下的工作就是变现了，无非就是页面交互和数据的增删改查了。细节点解析关于评论数量目前在文章的集合中有个 totalComments 这个属性，当这篇文章每新增一个评论时，需要加1。最初在写这个的时候，每次都是先查再更新，两段式，原代码如下：let count=post.totalComments+1;\r\nlet result =await db.collection('mini_posts').doc(event.commentContent.postId).update({\r\n    data: {\r\n      totalComments: count\r\n    }\r\n  });后来看文档发现，可以使用 db.command.inc 这个指令，无需再查一遍，直接可对原字段加1，还能保证原子性。代码如下：const _ = db.command\r\nlet result = db.collection('mini_posts').doc(event.commentContent.postId).update({\r\n    data: {\r\n      totalComments: _.inc(1)\r\n    }\r\n  });关于新增子评论需要实现在某个评论下进行回复。在交互上，点击评论者的昵称或头像时，触发相应的点击事件，在事件中去记录相应的评论ID及必要数据，同时去设置焦点到评论框内：/**\r\n  * 点击评论内容回复\r\n  */\r\n  focusComment: function (e) {\r\n    let that = this;\r\n    let name = e.currentTarget.dataset.name;\r\n    let commentId = e.currentTarget.dataset.id;\r\n    let openId = e.currentTarget.dataset.openid;\r\n\r\n    that.setData({\r\n      commentId: commentId,\r\n      placeholder: \"回复\" + name + \":\",\r\n      focus: true,\r\n      toName: name,\r\n      toOpenId: openId\r\n    });\r\n  },利用云开发新增子评论时可以使用 db.command.push 来进行操作「更新指令，对一个值为数组的字段，往数组尾部添加一个或多个值」，往子评论集合中新增：/**\r\n * 新增子评论\r\n * @param {} event \r\n */\r\nasync function addPostChildComment(event) {\r\n\r\n  let task = db.collection('mini_posts').doc(event.postId).update({\r\n    data: {\r\n      totalComments: _.inc(1)\r\n    }\r\n  });\r\n  await db.collection('mini_comments').doc(event.id).update({\r\n    data: {\r\n      childComment: _.push(event.comments)\r\n    }\r\n  })\r\n  await task;\r\n}关于判断是否已收藏在文章第一次加载时，我们需要判断下该用户是否有对该文章有相关操作，如果有相应的收藏和点赞操作，在初始化时需要更新相应的功能图标,核心代码如下：/**\r\n   * 获取收藏和喜欢的状态\r\n   */\r\n  getPostRelated: async function (blogId) {\r\n    let where = {\r\n      postId: blogId,\r\n      openId: app.globalData.openid\r\n    }\r\n    let postRelated = await api.getPostRelated(where, 1);\r\n    let that = this;\r\n    for (var item of postRelated.data) {\r\n      if (config.postRelatedType.COLLECTION === item.type) {\r\n        that.setData({\r\n          collection: { status: true, text: \"已收藏\", icon: \"favorfill\" }\r\n        })\r\n        continue;\r\n      }\r\n      if (config.postRelatedType.ZAN === item.type) {\r\n        that.setData({\r\n          zan: { status: true, text: \"已赞\", icon: \"appreciatefill\" }\r\n        })\r\n        continue;\r\n      }\r\n    }\r\n  },至于其他一些交互细节和代码细节，可以自行阅读源码去体会，如果有任何疑问或者有更好的实现方式，也可以与我沟通。总结这里主要想分享实现一个功能时候的过程，有想法的时候如何一步步去成功变现。小程序本身不难，相应的文档也很详细，但是组装的过程和逻辑的实现需要自身去思考和体会。如果你的想法和流程都非常清晰，但还是没办法实现你的预期功能，那我建议你先放放，先把 html , css , javascript 熟悉下，再看几遍小程序的文档，也许你当时面临的问题就不再是问题了。"}
{"title": "display: flex;’布局下使用‘white-space: nowrap;’导致的问题 ", "author": "Rolan", "pub_time": "2019-5-13 00:21", "content": "需求：在item中实现布局预期效果为：左侧一个正圆形的用户头像，右侧的上方为该用户昵称、下方为个性签名（单行显示，超出实际能显示的最大宽度则用‘...’代替）。如图：代码：wxml布局:<view class=\"member-item\">\r\n    <image class=\"avatar\" src=\"\"></image>\r\n    <view class=\"info\">\r\n      <view class=\"name\">姓名</view>\r\n      <view class=\"signature\">这个人很懒，什么都没写。这个人很懒，什么都没写。</view>\r\n    </view>\r\n  </view>wxss样式：.member-item {\r\n  margin-top: 1px;\r\n  padding: 15rpx 30rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  background-color: white;\r\n  width: auto;\r\n}\r\n \r\n.avatar {\r\n  background-color: whitesmoke;\r\n  width: 96rpx;\r\n  height: 96rpx;\r\n  border-radius: 50%;\r\n}\r\n.info {\r\n  display: flex;\r\n  flex-direction: column;\r\n  margin-left: 30rpx;\r\n  flex: 1;\r\n}\r\n.name {\r\n  font-size: 30rpx;\r\n  color: #333;\r\n  line-height: 48rpx;\r\n}\r\n.signature {\r\n  font-size: 28rpx;\r\n  color: #888;\r\n  line-height: 48rpx;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}效果：问题：为了自适应屏幕大小，这里父布局采用flex，展示个性签名的view对应的class为signature，其中我通过“overflow: hidden; text-overflow: ellipsis; white-space: nowrap;”来实现单行显示，超出实际能显示的最大宽度则用‘...’代替的效果。但是在实际效果如上图所示，当内容超出实际可显示宽度时，挤压推出左侧布局以显示signature中的内容，导致左侧布局的变形甚至被挤出。解决办法：在signature的父布局info中添加样式 min-width: 0; 即可解决。"}
{"title": "小程序开发前的准备工作 ", "author": "Rolan", "pub_time": "2019-5-13 00:56", "content": "磨刀不误砍柴工，在开发之前做好准备工作可以大大提升开发效率、减少冗余代码，这篇文章结合自己做过的几个小程序的经验做一个总结【demo地址】。\r\n\r\n\r\n相关参考 vant-weapp、武装你的小程序——开发流程指南\r\n\r\n着手开发小程序前都有哪些工作要准备？\r\n\r\n重写小程序Page、Component函数\r\nRequest方法封装\r\nRouter路由封装\r\nLess的使用\r\nUtil的封装\r\n\r\n\r\n为什么要重写Page、Component函数？\r\n\r\n准备开发页面之前你是否经历过这样...\r\n\r\nimport store from \"../utils/store\";\r\nimport util from \"../utils/util\";\r\nimport fetch from \"../utils/fetch\";\r\nimport config from \"../utils/config\";\r\n\r\nPage ({\r\n  // ...  \r\n})\r\n复制代码每个页面都要复制粘贴 我@#$%^&*\r\n\r\n以下办法可能会解决这些问题 并且相当舒适\r\n\r\n创建Init.js 并引入到app.js里， 像这样⬇️\r\n\r\nrequire('./utils/Init.js');\r\n\r\nApp({\r\n  onLaunch: function () {}\r\n})\r\n复制代码\r\n重写Page、Component函数\r\n\r\n\r\n函数重写思考：小程序属于单页面应用，全局的页面组件注册全依靠Page、Component函数，实际上就是调用了一个函数 传入了一个对象，那我们能不能在函数调用前，对参数做一些小动作呢？\r\n\r\n先来试验一下\r\n编辑Init.js\r\n// 函数劫持 重写注册函数\r\nlet originPage = Page;\r\nPage = (opt) => {\r\n    // 在传入Page函数的参数中 添加一个util对象\r\n    opt.util = {\r\n        test () {\r\n            return 1;\r\n        }\r\n    }\r\n    return originPage(opt);\r\n}\r\n复制代码在页面onLoad方法中测试一下\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function () {\r\n    console.log(this.util.test())\r\n  }\r\n})\r\n复制代码结果输出如下\r\n输出结果\r\n运行成功！接下来你应该懂我的意思 塞他！\r\n编辑Init.js\r\nimport _store from \"./store\";\r\nimport _util from \"./util\";\r\nimport _fetch from \"./fetch\";\r\n\r\nlet originPage = Page;\r\nPage = (opt) => {\r\n    // 把创建好的工具类引入opt参数内\r\n    opt = {\r\n        ...opt,\r\n        _store,\r\n        _util,\r\n        _fetch\r\n    }\r\n    return originPage(opt);\r\n}\r\n复制代码然后在页面中输出一下this关键字\r\n嗯...终于不用引乱七八糟的东西了\r\n注意！Component函数中如果也这么写 组件实例中并不会出现添加的对象 像这样 \r\n// Init.js\r\nimport _store from \"./store\";\r\nimport _util from \"./util\";\r\nimport _fetch from \"./fetch\";\r\n\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n    opt.util = {\r\n        test() {\r\n            return 1\r\n        }\r\n    }\r\n    return originComponent(opt);\r\n}\r\n\r\n------------\r\n// components/img/index.js\r\nComponent({\r\n  attached () {\r\n    this.test();\r\n  },\r\n  methods: {\r\n    test() {\r\n      console.log(this.util)\r\n    }\r\n  }\r\n})\r\n\r\n复制代码运行结果\r\n但这就不代表我没有办法 \r\n编辑init.js 重写component部分\r\nComponent = (opt) => {\r\n  // Component函数的options无法直接插入参数 只能在某个生命周期函数被调用时动态赋值\r\n  let originAttached = opt.attached || function () {};\r\n  opt.attached = function(e) {\r\n    this.util = {\r\n      a() {\r\n        return 1;\r\n      }\r\n    };\r\n    return originAttached.apply(this);\r\n  }\r\n  return originComponent(opt)\r\n}\r\n复制代码运行结果\r\n最终把下面的各种工具类添加上之后 简单写个请求、跳转 大概就是这个样子\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function ({ goodId }) {\r\n    this._fetch({\r\n      url: \"getGoods\",\r\n      data: { goodId }\r\n    }).then(res => {\r\n      if (res.length) {\r\n        this._router.go(\"detail\", { firstGoodsId: res[0].id })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码\r\n\r\n以下是工作中各种用到的封装\r\nRequest方法封装\r\n\r\nwx.request方法封装点：请求状态、错误统一处理，以当前上下文可控制页面所有需要请求状态的组件\r\n\r\nFetch.js\r\nconst host = {\r\n  Dev: \"http://test.com\"\r\n}\r\n\r\nconst api = {\r\n  getUserInfo: \"...\",\r\n  getGoods: \"...\"\r\n}\r\n\r\nexport default function ({ url, data, showLoading = false }) {\r\n  let self = this;\r\n  changeFetchState(self, true);\r\n  showLoading && wx.showLoading({ title: showLoading })\r\n  return new Promise((resolve, reject) => {\r\n    const options = {\r\n      url: host.Dev + api[url],\r\n      method: \"POST\",\r\n      header: { \"content-type\": \"application/json\" },\r\n      data,\r\n      success: ({ data }) => {\r\n        resolve(data.data, data);\r\n      },\r\n      fail: err => {\r\n        reject(err);\r\n      },\r\n      complete() {\r\n        changeFetchState(self, false);\r\n        showLoading && wx.hideLoading();\r\n      }\r\n    };\r\n\r\n    wx.request(options);\r\n  })\r\n}\r\n// 以当前作用域调用，可控制页面需要请求状态的组件\r\nfunction changeFetchState (self, state) {\r\n  self && self.setData({ _fetchState: state });\r\n}\r\n复制代码\r\nRouter路由封装\r\n\r\n规范路由管理、传参，以{key:value}形式定义路由，重新封装路由跳转方法，方便调用。\r\n\r\nRouter.js\r\n// 路由定义\r\nconst routePath = {\r\n  \"index\": \"/pages/index/index\",\r\n  \"detail\": \"/pages/detail/index\",\r\n  \"service\": \"/pages/service/index\"\r\n};\r\n// tabbar名单 特殊处理\r\nconst tabbar = ['index', 'service']\r\n\r\nconst Router = {\r\n  // 参数转换\r\n  parse: function (data) {\r\n    if (!data) return '';\r\n    let tempArr = [];\r\n    for (let key in data) {\r\n      tempArr.push(`${key}=${encodeURIComponent(data[key])`);\r\n    }\r\n    return '?' + tempArr.join('&');\r\n  },\r\n  go: function (path = 'index', params = null, duration = 0) {\r\n    setTimeout(() => {\r\n      const isTabbar = tabbar.indexOf(path) == -1;\r\n      // 如果是tabbar用switchTab方法切换\r\n      wx[isTabbar ? 'navigateTo' : 'switchTab']({\r\n        url: routePath[path] + this.parse(params),\r\n      })\r\n    }, duration * 1000);\r\n  },\r\n  goBack: function (delta = 1, duration) {\r\n    setTimeout(() => {\r\n      wx.navigateBack({ delta })\r\n    }, duration * 1000)\r\n  }\r\n}\r\n\r\nexport default Router;\r\n复制代码\r\nLess的使用\r\n首先全局安装less插件 npm install less -g\r\nWebStorm -> Preferences\r\nTools -> File Watchers -> 新建监听文件选择Less -> 【重点】设置Output文件格式为wxss\r\n\r\nUtil通用类封装\r\n\r\n自己常用的工具大概有这几种：Storage存储、页面地址取参、获取当前上下文等等，通常Util一下也想不全都是在开发中边用边写，以下几个为例子。\r\n\r\nUtil.js\r\n// Storage相关\r\nfunction getStore (name1, name2) {\r\n  if (!name1) return false;\r\n  let baseStore = wx.getStorageSync(name1);\r\n  if (!baseStore) return false;\r\n  return name2 ? (baseStore[name2] || '') : baseStore;\r\n}\r\nfunction setStore (name, value) {\r\n  if (!name) return false;\r\n  return wx.setStorageSync(name, value);\r\n}\r\nfunction setStoreChild (name1, name2, value) {\r\n  if (!name1 || !name2) return false;\r\n  let baseStore = getStore(name1) || {};\r\n  baseStore[name2] = value;\r\n  return setStore(name1, baseStore);\r\n}\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n/**\r\n * 获取当前页面上下文\r\n * @returns {*}\r\n */\r\nfunction getPageContext() {\r\n  var pages = getCurrentPages();\r\n  return pages[pages.length - 1];\r\n}\r\n/**\r\n * 获取元素\r\n * @param classItem\r\n */\r\nfunction $select(className, cb) {\r\n  const query = wx.createSelectorQuery().in(this)\r\n  query.select(className).boundingClientRect()\r\n  query.selectViewport().scrollOffset()\r\n  query.exec(function (res) {\r\n    cb(className.substr('0') === '#' ? res[0] : res);\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  getStore,\r\n  setStore,\r\n  setStoreChild,\r\n  getValueType,\r\n  getPageContext,\r\n  $select\r\n}\r\n复制代码"}
{"title": "微信严控学习类产品“打卡” ", "author": "Rolan", "pub_time": "2019-5-14 00:00", "content": "题图来源：视觉中国钛媒体快讯 | 5月13日消息：今天，微信安全中心公众号发布《关于利诱分享朋友圈打卡的处理公告》，整顿朋友圈诱导分享行为，认为其是非正常营销，严重影响朋友圈阅读体验。这些分享行为主要集中在某些公众号、APP软件等主体，他们通过以返学费、送实物等方式，利诱微信用户分享其链接（包括二维码图片等）到朋友圈打卡。微信方面表示，一经发现，微信团队将进行如下处理：包括但不限于停止链接内容在朋友圈继续传播、停止对相关域名或IP地址进行访问，封禁相关开放平台帐号或应用的分享接口；对重复多次违规及对抗行为的违规主体，将采取阶梯式处理机制，包括但不限于下调每日分享限额、限制使用微信登录功能接口、永久封禁帐号、域名、IP地址或分享接口；对涉嫌使用微信外挂并通过微信群实施诱导用户分享的个人帐号，将根据违规严重程度对该微信帐号进行阶梯式处罚。值得注意的是，钛媒体发现，在部分违规公式案例公式中，微信选择了四款产品均属于教育类产品，分别是流利阅读（流利说旗下产品）、火箭单词、轻课和薄荷阅读。微信官方这则公告一发布，立马引起教育圈内的躁动和讨论。一位从事在线教育的高管告诉钛媒体，其所加入大部分微信群都在转发这则公告，并且表示会对当前大部分在线教育公司的营销模式造成影响。对于被微信方面公开点名批评，钛媒体向流利说方面求证。对方表示，已经知悉公告，并且尊重并理解微信方面的治理。与此同时，流利说也对“流利阅读”打卡返款条件作出一定的修改。但是，流利说也不认可“打卡”是一种利诱分享的行为。该公司表示，“流利阅读”从未以任何形式要求用户通过朋友圈帮助获客。“发朋友圈”只是流利阅读作为教育产品，希望用户坚持使用“打卡”动作的重要一环，并非“利诱”，而是希望用户可以在大家的监督下养成坚持学习的习惯。实际上，利用微信流量池鼓励学员朋友圈打卡，一直是在线教育类产品的营销利器。比如说，流利说就推出了“199元100天打卡80天返费”的项目。这不仅可以从微信上获得更多流量，还是提升用户活跃度一大法宝。而对于部分用户而言，通过朋友圈打开“打卡”，尤其是学习类产品的打卡，在从平台获取薄利、监督学习进度的同时，还可以营造出一种积极向上的社交形象。但是，显然日活已过10亿的微信，已经不希望再被各方薅走流量的“羊毛”。微信早已出台《微信外部链接内容管理规范》禁止通过利益诱惑，诱导用户分享、传播外链内容或者微信公众帐号文章，这一次微信针对教育行业加大关注明确处罚力度。可以预见的是，这无疑对于依靠线上渠道裂变招生的教培公司是一记重拳。或许，微信朋友圈“整顿”可能只是个开始，今后他们不得不调整营销策略，以应对各大平台的“流量管控”。（本文首发钛媒体，作者/李程程）以下是流利说回应原文：尊敬的媒体老师，亲爱的产品用户：感谢各位对于流利说旗下产品“流利阅读”的关心。针对5月13日微信官方账号“微信安全中心”发出的《关于利诱分享朋友圈打卡的处理公告》，我们做如下说明：1、微信官方的公告已收悉，内部调整已经启动。我们尊重并理解微信官方在平台治理上做出的努力；2、“流利阅读”从未以任何形式要求用户通过朋友圈帮助获客。“发朋友圈”只是流利阅读作为教育产品，希望用户坚持使用“打卡”动作的重要一环，并非“利诱”，而是希望用户可以在大家的监督下养成坚持学习的习惯；3、“流利阅读”一直以来希望为用户提供优质的学习内容，因此，我们的分享内容也不以销售为目的；4、有鉴于以上三点，为了体现我们对于“用户第一”的坚持，我们决定从即日起，对于“流利阅读”打卡返费条款做如下调整：A、即日起，仍在参与原“199元100天打卡80天返费”课程的用户，无需朋友圈打卡，只需要每天完成当日课程，100天内坚持80天，即可获得全额奖学金；B、用户仍可自愿在朋友圈打卡，但不打卡不会对奖学金有任何影响；C、未来购买此课程的用户，朋友圈打卡不会对返费产生任何影响；最后，对于“流利阅读”的各位用户，我们作为服务提供方向因此受到困扰的用户表示抱歉。本次微信平台的处理针对产品运营方。请各位用户放心，我们已和微信官方进行过确认，已经使用“流利阅读”在微信朋友圈的打卡不会对个人用户造成任何不良影响。流利阅读团队2019年5月13日"}
{"title": "从 VantComponent 谈 小程序维护 ", "author": "Rolan", "pub_time": "2019-5-14 00:45", "content": "在开发小程序的时候，我们总是期望用以往的技术规范和语法特点来书写当前的小程序，所以才会有各色的小程序框架，例如 mpvue、taro 等这些编译型框架。当然这些框架本身对于新开发的项目是有所帮助。而对于老项目，我们又想要利用 vue 的语法特性进行维护，又该如何呢？\r\n在此我研究了一下youzan的 vant-weapp。而发现该项目中的组件是如此编写的。\r\nimport { VantComponent } from '../common/component';\r\n\r\nVantComponent({\r\n  mixins: [],\r\n  props: {\r\n    name: String,\r\n    size: String\r\n  },\r\n  // 可以使用 watch 来监控 props 变化\r\n  // 其实就是把properties中的observer提取出来\r\n  watch: {\r\n    name(newVal) {\r\n       ...\r\n    },\r\n    // 可以直接使用字符串 代替函数调用\r\n    size: 'changeSize'\r\n  },\r\n  // 使用计算属性 来 获取数据，可以在 wxml直接使用\r\n  computed: {\r\n    bigSize() {\r\n      return this.data.size + 100\r\n    }\r\n  }，\r\n  data: {\r\n    size: 0\r\n  },\r\n  methods: {\r\n    onClick() {\r\n      this.$emit('click');\r\n    },\r\n    changeSize(size) {\r\n       // 使用set\r\n       this.set(size)\r\n    }\r\n  },\r\n\r\n  // 对应小程序组件 created 周期\r\n  beforeCreate() {},\r\n\r\n  // 对应小程序组件 attached 周期\r\n  created() {},\r\n\r\n  // 对应小程序组件 ready 周期\r\n  mounted() {},\r\n\r\n  // 对应小程序组件  detached 周期\r\n  destroyed: {}\r\n});\r\n复制代码居然发现该组件写法整体上类似于 Vue 语法。而本身却没有任何编译。看来问题是出在了导入的 VantComponet 这个方法上。下面我们开始详细介绍一下如何利用 VantComponet 来对老项目进行维护。\r\nTLDR (不多废话，先说结论)\r\n小程序组件写法这里就不再介绍。这里我们给出利用 VantComponent 写 Page 的代码风格。\r\nimport { VantComponent } from '../common/component'; \r\n\r\nVantComponent({\r\n  mixins: [],\r\n  props: {\r\n    a: String,\r\n    b: Number\r\n  },\r\n  // 在页面这里 watch 基本上是没有作用了，因为只做了props 变化的watch，page不会出现 props 变化\r\n  // 后面会详细说明为何\r\n  watch： {},\r\n  // 计算属性仍旧可用\r\n  computed: {\r\n    d() {\r\n      return c++\r\n    }\r\n  },\r\n  methods: {\r\n    onLoad() {}\r\n  },\r\n  created() {},\r\n  // 其他组件生命周期\r\n})\r\n复制代码这里你可能感到疑惑，VantComponet 不是对组件 Component 生效的吗？怎么会对页面 Page 生效呢。事实上，我们是可以使用组件来构造小程序页面的。\r\n在官方文档中，我们可以看到 使用 Component 构造器构造页面\r\n事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法。代码编写如下:\r\nComponent({\r\n    // 可以使用组件的 behaviors 机制,虽然 React 觉得 mixins 并不是一个很好的方案\r\n    // 但是在某种程度该方案的确可以复用相同的逻辑代码\r\n    behaviors: [myBehavior],\r\n   \r\n    // 对应于page的options，与此本身是有类型的，而从options 取得数据均为 string类型\r\n    // 访问 页面 /pages/index/index?paramA=123&paramB=xyz \r\n    // 如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz，而不是 string类型\r\n    properties: {\r\n        paramA: Number,\r\n        paramB: String,\r\n    },\r\n    methods: {\r\n        // onLoad 不需要 option\r\n        // 但是页面级别的生命周期却只能写道 methods中来\r\n        onLoad() {\r\n            this.data.paramA // 页面参数 paramA 的值 123\r\n            this.data.paramB // 页面参数 paramB 的值 ’xyz’\r\n        }\r\n    }\r\n\r\n})\r\n复制代码那么组件的生命周期和页面的生命周期又是怎么对应的呢。经过一番测试，得出结果为： (为了简便。只会列出 重要的的生命周期)\r\n// 组件实例被创建 到 组件实例进入页面节点树\r\ncomponent created -> component attched -> \r\n// 页面页面加载 到  组件在视图层布局完成\r\npage onLoad -> component ready -> \r\n// 页面卸载 到 组件实例被从页面节点树移除\r\npage OnUnload -> component detached\r\n复制代码当然 我们重点不是在 onload 和 onunload 中间的状态，因为中间状态的时候，我们可以在页面中使用页面生命周期来操作更好。\r\n某些时候我们的一些初始化代码不应该放在 onload 里面，我们可以考虑放在 component create 进行操作，甚至可以利用 behaviors 来复用初始化代码。\r\n某种方面来说，如果不需要 Vue 风格，我们在老项目中直接利用 Component 代替 Page 也不失为一个不错的维护方案。毕竟官方标准，不用担心其他一系列后续问题。\r\nVantComponent 源码解析\r\nVantComponent\r\n此时，我们对 VantComponent 开始进行解析\r\n// 赋值，根据 map 的 key 和 value 来进行操作\r\nfunction mapKeys(source: object, target: object, map: object) {\r\n  Object.keys(map).forEach(key => {\r\n    if (source[key]) {\r\n      // 目标对象 的 map[key] 对应 源数据对象的 key\r\n      target[map[key]] = source[key];\r\n    }\r\n  });\r\n}\r\n\r\n// ts代码，也就是 泛型\r\nfunction VantComponent<Data, Props, Watch, Methods, Computed>(\r\n  vantOptions: VantComponentOptions<\r\n    Data,\r\n    Props,\r\n    Watch,\r\n    Methods,\r\n    Computed,\r\n    CombinedComponentInstance<Data, Props, Watch, Methods, Computed>\r\n  > = {}\r\n): void {\r\n  const options: any = {};\r\n  // 用function 来拷贝 新的数据，也就是我们可以用的 Vue 风格\r\n  mapKeys(vantOptions, options, {\r\n    data: 'data',\r\n    props: 'properties',\r\n    mixins: 'behaviors',\r\n    methods: 'methods',\r\n    beforeCreate: 'created',\r\n    created: 'attached',\r\n    mounted: 'ready',\r\n    relations: 'relations',\r\n    destroyed: 'detached',\r\n    classes: 'externalClasses'\r\n  });\r\n\r\n  // 对组件间关系进行编辑，但是page不需要，可以删除\r\n  const { relation } = vantOptions;\r\n  if (relation) {\r\n    options.relations = Object.assign(options.relations || {}, {\r\n      [`../${relation.name}/index`]: relation\r\n    });\r\n  }\r\n\r\n  // 对组件默认添加 externalClasses，但是page不需要，可以删除\r\n  // add default externalClasses\r\n  options.externalClasses = options.externalClasses || [];\r\n  options.externalClasses.push('custom-class');\r\n\r\n  // 对组件默认添加 basic，封装了 $emit 和小程序节点查询方法，可以删除\r\n  // add default behaviors\r\n  options.behaviors = options.behaviors || [];\r\n  options.behaviors.push(basic);\r\n\r\n  // map field to form-field behavior\r\n  // 默认添加 内置 behavior  wx://form-field\r\n  // 它使得这个自定义组件有类似于表单控件的行为。\r\n  // 可以研究下文给出的 内置behaviors\r\n  if (vantOptions.field) {\r\n    options.behaviors.push('wx://form-field');\r\n  }\r\n\r\n  // add default options\r\n  // 添加组件默认配置，多slot\r\n  options.options = {\r\n    multipleSlots: true,// 在组件定义时的选项中启用多slot支持\r\n    // 如果这个 Component 构造器用于构造页面 ，则默认值为 shared\r\n    // 组件的apply-shared，可以研究下文给出的 组件样式隔离\r\n    addGlobalClass: true \r\n  };\r\n\r\n  // 监控 vantOptions\r\n  observe(vantOptions, options);\r\n\r\n  // 把当前重新配置的options 放入Component\r\n  Component(options);\r\n}\r\n复制代码内置behaviors\r\n组件样式隔离\r\nbasic behaviors\r\n刚刚我们谈到 basic behaviors，代码如下所示\r\nexport const basic = Behavior({\r\n  methods: {\r\n    // 调用 $emit组件 实际上是使用了 triggerEvent\r\n    $emit() {\r\n      this.triggerEvent.apply(this, arguments);\r\n    },\r\n\r\n    // 封装 程序节点查询\r\n    getRect(selector: string, all: boolean) {\r\n      return new Promise(resolve => {\r\n        wx.createSelectorQuery()\r\n          .in(this)[all ? 'selectAll' : 'select'](selector)\r\n          .boundingClientRect(rect => {\r\n            if (all && Array.isArray(rect) && rect.length) {\r\n              resolve(rect);\r\n            }\r\n\r\n            if (!all && rect) {\r\n              resolve(rect);\r\n            }\r\n          })\r\n          .exec();\r\n      });\r\n    }\r\n  }\r\n});\r\n复制代码observe\r\n小程序 watch 和 computed的 代码解析\r\nexport function observe(vantOptions, options) {\r\n  // 从传入的 option中得到 watch computed  \r\n  const { watch, computed } = vantOptions;\r\n\r\n  // 添加  behavior\r\n  options.behaviors.push(behavior);\r\n\r\n  /// 如果有 watch 对象\r\n  if (watch) {\r\n    const props = options.properties || {};\r\n    // 例如: \r\n    // props: {\r\n    //   a: String\r\n    // },\r\n    // watch: {\r\n    //   a(val) {\r\n    //     // 每次val变化时候打印\r\n    //     consol.log(val)\r\n    //   }\r\n    } \r\n    Object.keys(watch).forEach(key => {\r\n      \r\n      // watch只会对prop中的数据进行 监视\r\n      if (key in props) {\r\n        let prop = props[key];\r\n        if (prop === null || !('type' in prop)) {\r\n          prop = { type: prop };\r\n        }\r\n        // prop的observer被watch赋值，也就是小程序组件本身的功能。\r\n        prop.observer = watch[key];\r\n        // 把当前的key 放入prop\r\n        props[key] = prop;\r\n      }\r\n    });\r\n    // 经过此方法\r\n    // props: {\r\n    //  a: {\r\n    //    type: String,\r\n    //    observer: (val) {\r\n    //      console.log(val)\r\n    //    }\r\n    //  }\r\n    // }\r\n    options.properties = props;\r\n  }\r\n\r\n  // 对计算属性进行封装\r\n  if (computed) {\r\n    options.methods = options.methods || {};\r\n    options.methods.$options = () => vantOptions;\r\n\r\n    if (options.properties) {\r\n      \r\n      // 监视props，如果props发生改变，计算属性本身也要变\r\n      observeProps(options.properties);\r\n    }\r\n  }\r\n}\r\n复制代码observeProps\r\n现在剩下的也就是 observeProps 以及 behavior 两个文件了，这两个都是为了计算属性而生成的，这里我们先解释 observeProps 代码\r\nexport function observeProps(props) {\r\n  if (!props) {\r\n    return;\r\n  }\r\n\r\n  Object.keys(props).forEach(key => {\r\n    let prop = props[key];\r\n    if (prop === null || !('type' in prop)) {\r\n      prop = { type: prop };\r\n    }\r\n\r\n    // 保存之前的 observer，也就是上一个代码生成的prop\r\n    let { observer } = prop;\r\n    prop.observer = function() {\r\n      if (observer) {\r\n        if (typeof observer === 'string') {\r\n          observer = this[observer];\r\n        }\r\n\r\n        // 调用之前保存的 observer\r\n        observer.apply(this, arguments);\r\n      }\r\n\r\n      // 在发生改变的时候调用一次 set 来重置计算属性\r\n      this.set();\r\n    };\r\n    // 把修改的props 赋值回去\r\n    props[key] = prop;\r\n  });\r\n}\r\n复制代码behavior\r\n最终 behavior，也就算 computed 实现机制\r\n\r\n// 异步调用 setData\r\nfunction setAsync(context: Weapp.Component, data: object) {\r\n  return new Promise(resolve => {\r\n    context.setData(data, resolve);\r\n  });\r\n};\r\n\r\nexport const behavior = Behavior({\r\n  created() {\r\n    if (!this.$options) {\r\n      return;\r\n    }\r\n\r\n    // 缓存\r\n    const cache = {};\r\n    const { computed } = this.$options();\r\n    const keys = Object.keys(computed);\r\n\r\n    this.calcComputed = () => {\r\n      // 需要更新的数据\r\n      const needUpdate = {};\r\n      keys.forEach(key => {\r\n        const value = computed[key].call(this);\r\n        // 缓存数据不等当前计算数值\r\n        if (cache[key] !== value) {\r\n          cache[key] = needUpdate[key] = value;\r\n        }\r\n      });\r\n      // 返回需要的更新的 computed\r\n      return needUpdate;\r\n    };\r\n  },\r\n\r\n  attached() {\r\n    // 在 attached 周期 调用一次，算出当前的computed数值\r\n    this.set();\r\n  },\r\n\r\n  methods: {\r\n    // set data and set computed data\r\n    // set可以使用callback 和 then\r\n    set(data: object, callback: Function) {\r\n      const stack = [];\r\n      // set时候放入数据\r\n      if (data) {\r\n        stack.push(setAsync(this, data));\r\n      }\r\n\r\n      if (this.calcComputed) {\r\n        // 有计算属性，同样也放入 stack中，但是每次set都会调用一次，props改变也会调用\r\n        stack.push(setAsync(this, this.calcComputed()));\r\n      }\r\n\r\n      return Promise.all(stack).then(res => {\r\n        // 所有 data以及计算属性都完成后调用callback\r\n        if (callback && typeof callback === 'function') {\r\n          callback.call(this);\r\n        }\r\n        return res;\r\n      });\r\n    }\r\n  }\r\n});\r\n复制代码写在后面\r\n\r\n\r\njs 是一门灵活的语言(手动滑稽)\r\n\r\n\r\n本身 小程序 Component 在 小程序 Page 之后，就要比Page 更加成熟好用，有时候新的方案往往藏在文档之中，每次多看几遍文档绝不是没有意义的。\r\n\r\n\r\n小程序版本 版本2.6.1 Component  目前已经实现了 observers，可以监听 props data 数据监听器,目前 VantComponent没有实现，当然本身而言，Page 不需要对 prop 进行监听，因为进入页面压根不会变，而data变化本身就无需监听，直接调用函数即可，所以对page而言，observers 可有可无。\r\n\r\n\r\n该方案也只是对 js 代码上有vue的风格，并没在 template 以及 style 做其他文章。\r\n\r\n\r\n该方案性能一定是有所缺失的，因为computed是每次set都会进行计算，而并非根据set 的 data 来进行操作，在删减之后我认为本身是可以接受。如果本身对于vue的语法特性需求不高，可以直接利用 Component 来编写 Page，选择不同的解决方案实质上是需要权衡各种利弊。如果本身是有其他要求或者新的项目，仍旧推荐使用新技术，如果本身是已有项目并且需要维护的，同时又想拥有 Vue 特性。可以使用该方案，因为代码本身较少，而且本身也可以基于自身需求修改。\r\n\r\n\r\n同时，vant-weapp是一个非常不错的项目，推荐各位可以去查看以及star。"}
{"title": "在微信小程序与小游戏中使用 LeanCloud ", "author": "Rolan", "pub_time": "2019-4-29 00:37", "content": "微信小程序是一个全新的跨平台移动应用平台，小游戏是小程序的一个类目，在小程序的基础上开放了游戏相关的 API。LeanCloud 为小程序提供一站式后端云服务，为你免去服务器维护、证书配置等繁琐的工作，大幅降低你的开发和运维成本。本文说明了如何在微信小程序与小游戏中使用 LeanCloud 提供的各项服务。+Demo我们在小程序上实现了 LeanTodo 应用。在这个 Demo 中你可以看到：+如何集成 LeanCloud 用户系统，包括自动登录、unionid 绑定以及如何在登录后设置账号与密码以供用户在其他平台的 LeanTodo 应用上登录如何对云端数据进行查询、增加、修改与删除如何将查询结果数组绑定到视图层进行展示，以及如何在点击事件中得到对应的数组项如何使用 LiveQuery 实现对查询结果的实时更新和多端同步如何集成微信支付你可以通过微信扫描以下二维码进入 Demo。 Demo 的源码与运行说明请参考 https://github.com/leancloud/leantodo-weapp。+准备工作创建应用如果你还没有创建过 LeanCloud 应用，请登录 LeanCloud 控制台 创建一个新应用。如果你还没有小程序帐号，请访问 微信公众平台 注册一个小程序帐号。如果你不需要进行真机调试可以跳过这一步。下载 小程序开发工具，按照 小程序开发教程 创建一个项目。配置域名白名单请按照 小程序域名白名单配置 的步骤配置。如果你不需要进行真机调试可以跳过这一步（可在开发者工具的 详情 > 项目设置 中勾选不校验安全域名、TLS 版本以及 HTTPS 证书）。+安装与初始化 SDK要使用 LeanCloud 的结构化对象存储、文件存储、用户系统等功能，需要使用 LeanCloud 存储 SDK。存储 SDK 的安装与初始化请请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装存储 SDK 后即可在 app.js 中初始化应用：+// 获取 AV 命名空间的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst AV = require('./libs/av-weapp-min.js');\r\nAV.init({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。即时通讯 SDK 是与存储 SDK 独立的 SDK，我们在单独的 即时通讯 章节介绍其安装与初始化的步骤。+结构化对象存储所有的结构化对象存储 API 都能正常使用，详细的用法请参考 JavaScript 数据存储开发指南。+数据绑定AV.Object 实例是一些携带很多信息与方法的对象，而小程序的存放渲染用数据的 data 字段需要的是 JSON 类型的数据，因此我们需要将 AV.Object 实例处理为 JSON 数据后再设置给 data。+以 LeanTodo Demo 中的 Todo 列表为例，要实现「将 AV.Query 查询结果 Todo 列表中的 content 与 done 字段展示为列表」的功能，我们可以定义一个 getDataForRender 来做上面说的「处理」：+const getDataForRender = todo => ({\r\n  content: todo.get('content'),\r\n  done: todo.get('done')\r\n});\r\n\r\nPage({\r\n  data: {\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => this.setData({\r\n        todos: todos.map(getDataForRender)\r\n      }))\r\n      .catch(console.error);\r\n  }\r\n});AV.Object 提供了一个 #toJSON() 方法以 JSON 的形式返回其携带的有效信息。因此如果不考虑渲染性能，getDataForRender 可以简化为：+const getDataForRender = todo => todo.toJSON();使用 #toJSON() 会比手动 pick 需要的数据带来更多的性能消耗。这是因为小程序的 data 在逻辑层与渲染层之间是通过序列化后的字符串格式通讯的，过大的 data 结构会造成渲染耗时过久。因此对于结构复杂的 AV.Object，特别是如果是一个列表，手动 pick 需要的数据设置为 data 是一种常见的优化方法。+当然，每次 setData 时遇到不同结构中的 AV.Object 都要进行这样的处理会让代码充斥噪音，你可以使用各种技巧对此进行优化。这里分享一个 Demo 中使用的一个统一对 setData 的对象进行「处理」的 utility 方法 jsonify：+const isPlainObject = target =>\r\n  target &&\r\n  target.toString() == '[object Object]' &&\r\n  Object.getPrototypeOf(target) == Object.prototype;\r\nconst _jsonify = target => {\r\n  if (target && typeof target.toJSON === 'function') return target.toJSON();\r\n  if (Array.isArray(target)) return target.map(_jsonify);\r\n  return target;\r\n};\r\n\r\nconst jsonify = target =>\r\n  isPlainObject(target)\r\n    ? Object.keys(target).reduce(\r\n      (result, key) => ({\r\n        ...result,\r\n        [key]: _jsonify(target[key])\r\n      }),\r\n      {}\r\n    )\r\n    : _jsonify(target);jsonify 能正确的处理 AV.Object、AV.Object 数组以及其他类型的数据。使用时可以简单的在所有的 setData 之前对数据调用一次 jsonify 方法：+this.setData(jsonify({\r\n  todos, // AV.Object list\r\n  user, // AV.Object\r\n}));值得注意的是从 AV.Object 到 JSON 数据的处理是不可逆的，如果在之后还需要用到查询结果的 AV.Object，我们可以将其保存到 Page 实例上：+Page({\r\n  // todos 存放的是 AV.Object 列表，后续可以这些对象进行操作（比如调用其 save 方法），不参与渲染\r\n  todos: [],\r\n  data: {\r\n    // data.todo 存放的是 JSON 数据，供 WXML 页面渲染用\r\n    todos: []\r\n  },\r\n  onReady() {\r\n    new AV.Query('Todo')\r\n      .find()\r\n      .then(todos => {\r\n        this.todos = todos;\r\n        this.setData(jsonify({\r\n          todos\r\n        });\r\n      })\r\n      .catch(console.error);\r\n  },\r\n  saveAll() {\r\n    // 可以在这里获取到 this.todos 进行操作\r\n    return AV.Object.saveAll(this.todos)\r\n  }\r\n});你可能会在某些过时的文档或者 Demo 中看到直接使用 this.setData() 将 AV.Object 对象设置为当前页面的 data 的用法。我们 不再推荐这种用法。这是 SDK 针对小程序做的特殊「优化」，利用了小程序渲染机制中的一个未定义行为，目前已知在使用了自定义组件（usingComponents）时这种用法会失效。+文件存储在小程序中，可以将用户相册或拍照得到的图片上传到 LeanCloud 服务器进行保存。首先通过 wx.chooseImage 方法选择或拍摄照片，得到本地临时文件的路径，然后按照下面的方法构造一个 AV.File 将其上传到 LeanCloud：+wx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePaths[0];\r\n    // 使用本地临时文件的路径构造 AV.File\r\n    new AV.File('file-name', {\r\n      blob: {\r\n        uri: tempFilePath,\r\n      },\r\n    })\r\n      // 上传\r\n      .save()\r\n      // 上传成功\r\n      .then(file => console.log(file.url()))\r\n      // 上传发生异常\r\n      .catch(console.error);\r\n  }\r\n});上传成功后可以通过 file.url() 方法得到服务端的图片 url。+关于文件存储更详细的用法请参考 JavaScript 数据存储开发指南 · 文件。+用户系统小程序中提供了登录 API 来获取微信的用户登录状态，应用可以访问到用户的昵称、性别等基本信息。但是如果想要保存额外的用户信息，如用户的手机号码、收货地址等，或者需要在其他平台使用该用户登录，则需要使用 LeanCloud 的用户系统。+一键登录LeanCloud 的用户系统支持一键使用微信用户身份登录。要使用一键登录功能，需要先设置小程序的 AppID 与 AppSecret：+登录 微信公众平台，在 设置 > 开发设置 中获得 AppID 与 AppSecret。前往 LeanCloud 控制台 > 组件 > 社交，保存「微信小程序」的 AppID 与 AppSecret。这样你就可以在应用中使用 AV.User.loginWithWeapp() 方法来使用当前用户身份登录了。+AV.User.loginWithWeapp().then(user => {\r\n  this.globalData.user = user;\r\n}).catch(console.error);使用一键登录方式登录时，LeanCloud 会将该用户的小程序 openid 与 session_key 等信息保存在对应的 user.authData.lc_weapp 属性中，你可以在控制台的 _User 表中看到：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\"\r\n    }\r\n  }\r\n}如果用户是第一次使用此应用，调用登录 API 会创建一个新的用户，你可以在 控制台 > 存储 中的 _User 表中看到该用户的信息，如果用户曾经使用该方式登录过此应用（存在对应 openid 的用户），再次调用登录 API 会返回同一个用户。+用户的登录状态会保存在客户端中，可以使用 AV.User.current() 方法来获取当前登录的用户，下面的例子展示了如何为登录用户保存额外的信息：+// 假设已经通过 AV.User.loginWithWeapp() 登录\r\n// 获得当前登录用户\r\nconst user = AV.User.current();\r\n// 调用小程序 API，得到用户信息\r\nwx.getUserInfo({\r\n  success: ({userInfo}) => {\r\n    // 更新当前用户的信息\r\n    user.set(userInfo).save().then(user => {\r\n      // 成功，此时可在控制台中看到更新后的用户信息\r\n      this.globalData.user = user;\r\n    }).catch(console.error);\r\n  }\r\n});authData 默认只有对应用户可见，开发者可以使用 masterKey 在云引擎中获取该用户的 openid 与 session_key 进行支付、推送等操作。详情的示例请参考 支付。+小程序的登录态（session_key）存在有效期，可以通过 wx.checkSession() 方法检测当前用户登录态是否有效，失效后可以通过调用 AV.User.loginWithWeapp() 重新登录。+使用 unionid微信开放平台使用 unionid 来区分用户的唯一性，也就是说同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 都是同一个，而 openid 会是多个。如果你想要实现多个小程序之间，或者小程序与使用微信开放平台登录的应用之间共享用户系统的话，则需要使用 unionid 登录。+要在小程序中使用 unionid 登录，请先确认已经在 微信开放平台 绑定了该小程序+在小程序中有很多途径可以 获取到 unionid。不同的 unionid 获取方式，接入 LeanCloud 用户系统的方式也有所不同。+一键登录时静默获取 unionid当满足以下条件时，一键登录 API AV.User.loginWithWeapp() 能静默地获取到用户的 unionid 并用 unionid + openid 进行匹配登录。+微信开放平台帐号下存在同主体的公众号，并且该用户已经关注了该公众号。微信开放平台帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。要启用这种方式，需要在一键登录时指定参数 preferUnionId 为 true：+AV.User.loginWithWeapp({\r\n  preferUnionId: true,\r\n});使用 unionid 登录后，用户的 authData 中会增加 _weixin_unionid 一项（与 lc_weapp 平级）：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    },\r\n    \"_weixin_unionid\": {\r\n      \"uid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}用 unionid + openid 登录时，会按照下面的步骤进行用户匹配：+如果已经存在对应 unionid（authData._weixin_unionid.uid）的用户，则会直接作为这个用户登录，并将所有信息（openid、session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中。如果不存在匹配 unionid 的用户，但存在匹配 openid（authData.lc_weapp.openid）的用户，则会直接作为这个用户登录，并将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。如果不存在匹配 unionid 的用户，也不存在匹配 openid 的用户，则创建一个新用户，将所有信息（session_key、unionid 等）更新到该用户的 authData.lc_ewapp 中，同时将 unionid 保存到 authData._weixin_unionid.uid 中。不管匹配的过程是如何的，最终登录用户的 authData 都会是上面这种结构。+LeanTodo Demo 便是使用这种方式登录的，如果你已经关注了其关联的公众号（搜索 AVOSCloud，或通过小程序关于页面的相关公众号链接访问），那么你在登录后会在 LeanTodo Demo 的 设置 - 用户 页面看到当前用户的 authData 中已经绑定了 unionid。+需要注意的是：+如果用户不符合上述静默获取 unionid 的条件，那么就算指定了 preferUnionId 也不会使用 unionid 登录。如果用户符合上述静默获取 unionid 的条件，但没有指定 preferUnionId，那么该次登录不会使用 unionid 登录，但仍然会将获取到的 unionid 作为一般字段写入该用户的 authData.lc_weapp 中。此时用户的 authData 会是这样的：+{\r\n  \"authData\": {\r\n    \"lc_weapp\": {\r\n      \"session_key\": \"2zIDoEEUhkb0B5pUTzsLVg==\",\r\n      \"expires_in\": 7200,\r\n      \"openid\": \"obznq0GuHPxdRYaaDkPOHk785DuA\",\r\n      \"unionid\": \"ox7NLs5BlEqPS4glxqhn5kkO0UUo\"\r\n    }\r\n  }\r\n}通过其他方式获取 unionid 后登录如果开发者自行获得了用户的 unionid（例如通过解密 wx.getUserInfo 获取到的用户信息），可以在小程序中调用 AV.User.loginWithWeappWithUnionId() 投入 unionid 完成登录授权：+AV.User.loginWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);通过其他方式获取 unionid 与 openid 后登录如果开发者希望更灵活的控制小程序的登录流程，也可以自行在服务端实现 unionid 与 openid 的获取，然后调用通用的第三方 unionid 登录接口指定平台为 lc_weapp 来登录：+const unionid = '';\r\nconst authData = {\r\n  openid: '',\r\n  session_key: ''\r\n};\r\nconst platform = 'lc_weapp';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);相对上面提到的一些 Weapp 相关的登录 API，loginWithAuthDataAndUnionId 是更加底层的第三方登录接口，不依赖小程序运行环境，因此这种方式也提供了更高的灵活度：+可以在服务端获取到 unionid 与 openid 等信息后返回给小程序客户端，在客户端调用 AV.User.loginWithAuthDataAndUnionId 来登录。也可以在服务端获取到 unionid 与 openid 等信息后直接调用 AV.User.loginWithAuthDataAndUnionId 登录，成功后得到登录用户的 sessionToken 后返回给客户端，客户端再使用该 sessionToken 直接登录。关联第二个小程序这种用法的另一种常见场景是关联同一个开发者帐号下的第二个小程序。+因为一个 LeanCloud 应用默认关联一个微信小程序（对应的平台名称是 lc_weapp），使用小程序系列 API 的时候也都是默认关联到 authData.lc_weapp 字段上。如果想要接入第二个小程序，则需要自行获取到 unionid 与 openid，然后将其作为一个新的第三方平台登录。这里同样需要用到 AV.User.loginWithAuthDataAndUnionId 方法，但与关联内置的小程序平台（lc_weapp）有一些不同：+需要指定一个新的 platform需要将 openid 保存为 uid（内置的微信平台做了特殊处理可以直接用 openid 而这里是作为通用第三方 OAuth 平台保存因此需要使用标准的 uid 字段）。这里我们以新的平台 weapp2 为例：+const unionid = '';\r\nconst openid = '';\r\nconst authData = {\r\n  uid: openid,\r\n  session_key: ''\r\n};\r\nconst platform = 'weapp2';\r\nAV.User.loginWithAuthDataAndUnionId(authData, platform, unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);获取 unionid 后与现有用户关联如果一个用户已经登录，现在通过某种方式获取到了其 unionid（一个常见的使用场景是用户完成了支付操作后在服务端通过 getPaidUnionId 得到了 unionid）希望与之关联，可以在小程序中使用 AV.User#associateWithWeappWithUnionId()：+const user = AV.User.current(); // 获取当前登录用户\r\nuser.associateWithWeappWithUnionId(unionid, {\r\n  asMainAccount: true\r\n}).then(console.log, console.error);启用其他登录方式上述的登录 API 对接的是小程序的用户系统，所以使用这些 API 创建的用户无法直接在小程序之外的平台上登录。如果需要使用 LeanCloud 用户系统提供的其他登录方式，如用手机号验证码登录、邮箱密码登录等，在小程序登录后设置对应的用户属性即可：+// 小程序登录\r\nAV.User.loginWithWeapp().then(user => {\r\n  // 设置并保存手机号\r\n  user.setMobilePhoneNumber('13000000000');\r\n  return user.save();\r\n}).then(user => {\r\n  // 发送验证短信\r\n  return AV.User.requestMobilePhoneVerify(user.getMobilePhoneNumber());\r\n}).then({\r\n  // 用户填写收到短信验证码后再调用 AV.User.verifyMobilePhone(code) 完成手机号的绑定\r\n  // 成功后用户的 mobilePhoneVerified 字段会被置为 true\r\n  // 此后用户便可以使用手机号加动态验证码登录了\r\n}).catch(console.error);验证手机号码功能要求在 控制台 > 存储 > 设置 > 用户账号 启用「用户注册时，向注册手机号码发送验证短信」。+绑定现有用户如果你的应用已经在使用 LeanCloud 的用户系统，或者用户已经通过其他方式注册了你的应用（比如在 Web 端通过用户名密码注册），可以通过在小程序中调用 AV.User#associateWithWeapp() 来关联已有的账户：+// 首先，使用用户名与密码登录一个已经存在的用户\r\nAV.User.logIn('username', 'password').then(user => {\r\n  // 将当前的微信用户与当前登录用户关联\r\n  return user.associateWithWeapp();\r\n}).catch(console.error);即时通讯要使用 LeanCloud 的即时通讯服务实现聊天等功能，需要使用 LeanCloud 即时通讯 SDK。+安装与初始化请参阅《JavaScript SDK 安装指南》中对应平台的说明。+安装 SDK 后即可在 app.js 中初始化应用：+// Realtime 类获取的方式根据不同的安装方式而异，这里假设是通过手动导入文件的方式安装的 SDK\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\n 需要特别注意的是，小程序对 WebSocket 连接的数量是有限制的，因此推荐的用法是初始化 Realtime 一次，挂载到全局的 App 实例上，然后在所有需要的时候都使用这个 Realtime 实例。+// app.js\r\nconst { Realtime } = require('./libs/realtime.weapp.min.js');\r\nconst realtime = new Realtime({\r\n  appId: '{{appid}}',\r\n  appKey: '{{appkey}}',\r\n});\r\nApp({\r\n  realtime: realtime,\r\n  // ...\r\n});\r\n\r\n// some-page.js\r\nconst realtime = getApp().realtime;\r\n 即时通讯 SDK 的详细用法请参考 即时通讯开发指南。+富媒体消息要在小程序中使用即时通讯 SDK 的富媒体消息插件，有一些额外的约束：+安装存储 SDK 至 libs 目录，并将文件重命名为 leancloud-storage.js。安装即时通讯 SDK 至 libs 目录，并将文件重命名为 leancloud-realtime.js。下载 leancloud-realtime-plugin-typed-messages.js，移动到 libs 目录。必须保证三个文件在同一目录中。在 app.js 中依次加载 leancloud-storage.js、leancloud-realtime.js 和 leancloud-realtime-plugin-typed-messages.js。const AV = require('./libs/leancloud-storage.js');\r\nconst Realtime = require('./libs/leancloud-realtime.js').Realtime;\r\nconst TypedMessagesPlugin = require('./libs/leancloud-realtime-plugin-typed-messages.js').TypedMessagesPlugin;\r\nconst ImageMessage = require('./libs/leancloud-realtime-plugin-typed-messages.js').ImageMessage;在 app.js 中初始化应用：// 初始化存储 SDK\r\nAV.init({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n});\r\n// 初始化即时通讯 SDK\r\nconst realtime = new Realtime({\r\n appId: '{{appid}}',\r\n appKey: '{{appkey}}',\r\n plugins: [TypedMessagesPlugin], // 注册富媒体消息插件\r\n});\r\n 富媒体消息的用法请参考 即时通讯开发指南 - 富媒体消息。+数据绑定使用即时通讯 SDK，一个常见的需求是将 Conversation 与 Message 类型的数据绑定到视图层进行渲染。这里会遇到一些与结构化数据存储 SDK 一样的问题，其解决方案与最佳实践请参考结构化数据存储的 数据绑定 章节（Conversation 与 Message 都实现了 #toJSON 方法，上文中介绍的 jsonify 方法同样适用于Conversation 与 Message 实例）。+支付配置在开始之前，请确保已经在微信小程序后台开启了「微信支付」功能，然后按照下面的步骤配置云引擎环境变量：2进入应用控制台 - 云引擎 - 设置设置应用的二级域名并保存添加并保存以下环境变量WEIXIN_APPID：小程序 AppIdWEIXIN_MCHID：微信支付商户号WEIXIN_PAY_SECRET：微信支付 API 密钥（微信商户平台 - 账户设置 - API安全 - 密钥设置）WEIXIN_NOTIFY_URL：https://.leanapp.cn/weixin/pay-callback，其中 yourdomain 是第二步中设置的二级域名查看示例服务端开发首先确认本机已经安装 Node.js 运行环境和 LeanCloud 命令行工具，然后执行下列指令下载示例项目：+$ git clone https://github.com/leancloud/weapp-pay-getting-started.git\r\n$ cd weapp-pay-getting-started安装依赖：+npm install登录并关联应用：+lean login\r\nlean switch启动项目：+lean up之后你就可以在 localhost:3001 调试云函数了。+示例项目中与支付直接相关代码有三部分：+order.js：对应 Order 表，定义了部分字段的 getter/setter，以及 place 方法用于向微信 API 提交订单。cloud.js：其中定义了名为 order 的云函数，这个云函数会获取当前用户的 openid，以其身份创建了一个 1 分钱的 order 并下单，最后返回签名过的订单信息。routers/weixin.js：其中定义了 pay-callback 的处理函数，当用户支付成功后微信调用这个 URL，这个函数将对应的订单状态更新为 SUCCESS。请根据你的业务需要修改代码。参考文档：+微信支付统一下单 API 参数与错误码微信支付结果通知参数完成开发后部署到预备环境（若无预备环境则直接部署到生产环境）：+lean deploy客户端开发客户端完成一次支付需要分两步：+用户登录后，调用名为 order 的云函数下单，返回签名过的订单信息。调用支付 API（wx.requestPayment），传入上一步返回的订单信息，发起支付。AV.Cloud.run('order').then((data) => {\r\n  data.success = () => {\r\n    // 支付成功\r\n  });\r\n  data.fail = ({ errMsg }) => {\r\n    // 错误处理\r\n  });\r\n  wx.requestPayment(data);\r\n}).catch(error => {\r\n  // 错误处理\r\n})客户端的示例代码参见 Demo 打赏功能。参考文档：2小程序客户端发起支付 APIFAQ配置 download 合法域名时显示「该域名因违规被禁止设置。」请前往 控制台 > 存储 > 设置 > 文件 配置你自己的文件域名。+Access denied by api domain white list如果你的应用启用并配置了 Web 安全域名，你可能会 catch 到 Access denied by api domain white list 异常，请将提示的域名添加至应用的 Web 安全域名列表。+小程序真机上传数据时，控制台存储中显示的 Class 表名被压缩为单个字母。例如新建一个名为「Todo」的表，上传数据成功后进入控制台查看，其表名称显示为像 i、u 这样的单个字母。这是因为真机上代码会被压缩，解决办法是在创建 Class 后向 SDK 注册该 Class 的名字：AV.Object.register(Todo, 'Todo');。+反馈如果在微信小程序中使用 LeanCloud 时遇到问题，欢迎通过我们的 论坛 进行反馈。"}
{"title": "微信小程序怎么使用icon ", "author": "Rolan", "pub_time": "2019-4-30 00:21", "content": "小程序怎么使用icon第一步 下载icon我选择的图标库是阿里图标官网， 加入购物车第二步 转换ttf因为小程序的wxss文件的font-face的url不接受http地址作为参数,但可以接受base64,因此需将字体文件下载后,转换为base64，然后引用进入https://transfonter.org/平台点击Add fonts，添加iconfont.ttf勾选Base64 encode点击 convert 完成转换按照上图1,2,3的步骤 转换完成， 点击Download第三步 在微信小程序中使用icon解压 第二步中的文件夹找到stylesheet.css 文件打开第一步中压缩包的iconfont.css，把里面圈红的部分（即fontface部分我们不需要啦）复制到stylesheet.css修改后的stylesheet.css修改stylesheet.css的文件后缀为wxss，即stylesheet.wxss把stylesheet.wxss放进微信小程序的公共文件里面，然后把整个文件import到页面的样式表里在wxml页面引入使用完结"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序端实现文本展示以及标题定位 ", "author": "Rolan", "pub_time": "2019-2-18 00:34", "content": "探讨一个针对文本内容设置标题定位的业务场景。\r\n业务场景\r\n管理后台录入/编辑一段md或富文本协议，小程序端进行展示协议，且在小程序实现标题侧边栏，能快速定位至对应的内容。如图所示\r\n\r\n\r\n管理后台：录入内容实现方式\r\n1. 产出 长文本\r\n管理后台录入时，录入以markdown格式或富文本格式。\r\n由于项目在早期已进入开发，当时对markdown的转化工具兼容性较低，所以选择采取以富文本的方式进行保存。\r\n2. 产出 标题列表\r\n录入后，检索出对应的标题，将标题赋予对应标识，产出 标题列表。\r\n客户端：小程序实现方式\r\n小程序的实现方式有多种，先讲比较常用的两种方式：\r\n方式一：wxParse + <scrollView>\r\n采用微信小程序创建 wxParse —— 微信小程序富文本解析组件，支持Html及markdown转wxml可视化。\r\n\r\n\r\n优点\r\n\r\n对富文本支持程度很高，样式上可以按需调整\r\n易定制化，对于图片、链接等，可根据不同需要来控制其点击效果\r\n\r\n\r\n\r\n缺点\r\n\r\n解析时间随着元素的数量而不同。对html元素都进行解析，如果遇到一些表格类型，就会有特别多<tr> 、<td> 标签，解析速度非常缓慢，导致等待时间很长，用户体验不好。但如果采用方式二，就可以避开对内容的解析，不需要再控制解析时间。\r\n\r\n\r\n\r\n方式二：web-view + 网页展示\r\n文本的内容就全部放到一个h5网页来实现，在小程序端就通过 web-view 组件来展示这个网页内容。\r\n但对于标题的定位跳转，也可以有不同实现方式：\r\n<a> 标签做标题跳转的锚点\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n\r\n\r\n\r\n缺点\r\n\r\n\r\n通过触发点击带锚点的链接，浏览器前进后退可能导致hash的变化。点击返回的时候，返回的不是上一页面，而是上一个定位的位置。详情可查看《理解浏览器历史记录》\r\n\r\n\r\n\r\n\r\n\r\n由于用<a> 标签做标题跳转的锚点的方式，对\"返回\"按钮不友好，所以采用另一种方式，用 js 模仿 <a> 标签跳转。\r\njs 控制滚动，仿 <a> 标签跳转\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n能返回上一页面\r\n\r\n\r\n\r\n缺点\r\n\r\n需要处理那些非业务域名下的链接跳转，否则会弹出非法域名的提示，对用户不友好。\r\n微信其他组件的使用受到限制，例如点击图片预览等，需要加jssdk配置\r\n\r\n不过上述的两个缺点都可以通过网页进行解决，剩下的是开发便捷性的问题。\r\n\r\n\r\n总结\r\n上面的实现方式仅仅是富文本的方式，如今对 markdown 格式的应用和转化的支持性都有所提高，所以针对 markdown 格式的文本，也可以做类似的探讨。如果你有想法可以和我们一起交流，并且我们也在招聘 web前端开发工程师 ，如果有兴趣也可以加入我们哟O(∩_∩)O ，了解更多或者投递简历到邮箱 web@talkmoney.cn。\r\n\r\n\r\n作者简介：土拨鼠，芦苇科技web前端开发工程师，代表作品：飞花亭小程序、续航基因、YY表情红包、YY叠方块直播竞赛小游戏。擅长网站建设、公众号开发、微信小程序开发、小游戏、公众号开发，专注于前端框架、服务端渲染、SEO技术、交互设计、图像绘制、数据分析等研究，有兴趣的小伙伴来撩撩我们~ web@talkmoney.cn"}
{"title": "离岛日签 | 微信小程序云开发初体验 ", "author": "Rolan", "pub_time": "2019-2-22 00:45", "content": "题图：摄于上海喜马拉雅艺术馆很多事情的开始都是长存于潜意识的精神需求和偶然的决定性契机相结合导致的结果，接触摄影也差不多，以前对于艺术的未知抱有一种神秘的向往，总觉得人的一生应该有一个时间段去了解某一种艺术门类，近而可以通过这扇大门拥抱更广阔的世界。契机可能就是8年前来到了上海，发现摄影相对其他门类是打开一扇大门最易找到的一把钥匙。当然就像一位老师说过“摄影很难，难在太简单了”，钥匙容易找到，寻找广阔的世界并不容易。先从城市街景再到后来到处旅拍，要说摄影对我来说最大的意义是什么？就像上面提到的，这是一扇可以去触及艺术的大门。可能艺术离大多数摄影作品来说有很远的距离，但是就算远，有了方向就能走下去，总会有一天可以触摸到“何为艺术”这个问题的边缘。积极的看，也许沉浸在一个爱好中，会让自己专注，让生活充实，但是也可能错过其他的东西，我不同意说摄影就是无休止地按下快门，记录下身边的一切，我更同意，去体会和热爱生活的点点滴滴后拍下更喜欢的照片，而并非为拍而拍。我觉得文字和照片都是岁月里最好的记录者，于是我想为此开发一个简单的小应用来作为我记录的工具，考虑到微信小程序生态已经发展的比较完善了，特别是小程序云开发能力为开发者提供了完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。下面是我开发的第一个微信小程序：我这个小程序很简单，简单介绍一下：1、文艺、治愈、减压的文字照片记录分享小程序；2、上拉下滑，左右滑动都可以切换文字和图片，用户也可以将文字分享给好友；3、总有一段文字适合你现在的心境，每天打开小程序你都可以收获不一样的惊喜。好啦接下来我大致讲一下我的开发体验：整个开发流程中涉及的服务微信开发者工具都有提供，而且对于有一定开发能力的同学来说上手也很简单，参照官方文档很容易搭建起小程序的初始框架。微信这个开发者工具麻雀虽小五脏俱全从开发、调试、代码版本管理、测试、发布等产品开发上线一条龙服务全都有，下面是云开发控制台。在控制台这里可以直接管理云开发资源，接下来我把开发中遇到的一些小问题跟大家分享一下：1、数据库环境切换用户开通云开发后初始默认可拥有最多两个环境。在实际开发中，建议每一个正式环境都搭配一个测试环境，所有功能先在测试环境测试完毕后再上到正式环境，当我们在测试环境开发完成后要发布上线前，记得把数据库环境指定为正式环境，如下图在根目录的app.js文件中配置：2、添加数据和资源云开发提供了一个 JSON 数据库，这里完全是图形化的操作，设计好你的数据库结构和字段就可以手动添加了：云开发还提供了一块存储空间，提供了上传文件到云端、带权限管理的云端下载能力，开发者可以在小程序端和云函数端通过 API 使用云存储功能。这里顺便提一下，微信本身会对上传的图片资源进行压缩，不过如果图片本身就很大，压缩后依然也会比较大，经过实验当图片资源过大会导致小程序内存紧张容易出现白屏现象，建议不要加载过大的图片资源。3、有时候读取数据的时候会出现空数组的情况一般是上面数据库部分和存储部分的权限设置未修改4、读取数据进行前端展示由于云开发提供了数据库，所以我们可以不用部署自己的服务器通过HTTP调用数据库数据，直接通过微信提供的数据库API就可以直接获取后端数据进行展示。5、基础库换成最新的另外由于一些新特性需要依赖高版本的基础库，所以记得在项目详情页中调整基础库的版本。6、测试服务不稳定微信开发者工具虽然提供了测试服务，但由于此功能还在优化中所以存在不稳定现象，如果你发现自己申请的测试报告一直报超时，不是你的姿势有问题，请在开发者论坛反馈。7、定时触发通知任务因为我的小程序提供了通知功能，但希望这个动作可以做到每日定时发送，在没有第三方服务器的情况下，好在微信云开发提供了定时触发器的功能，而且还支持在云函数中调用HTTP请求，这样就可以方便的接入任何第三方通知服务了，如下：记得在云函数中也要指定数据库环境，另外如果要在云函数中使用request的方法，要单独申明：配置好定时触发器之后记得要上传！想要明白些道理，遇见些有趣的事 —— 离岛"}
{"title": "从前端程序员的视角看小程序的稳定性保障 ", "author": "Rolan", "pub_time": "2019-3-1 00:31", "content": "当我们谈业务稳定性的时候，通常是指后端工程师从架构的角度来看的，例如限流和降级、流量调度、业务开关、容量压测等，但监控也是整个业务稳定性建设中不可或缺的一环，例如对业务和前端的监控，以保证出现问题的时候，可以第一时间找到根因所在。今天，我们就结合小程序的场景，来看看如何做好小程序的监控。本文转载至InfoQ大前端技术号「前端之巅」，作者慕扉，阿里巴巴高级前端工程师。小程序与 H5 的不同小程序和 H5 都属于移动端场景下的技术选择方案，那么这里介绍一下小程序与 H5 的不同。1. 运行环境的不同传统的 H5 的运行环境是浏览器，包括 webview，其中浏览器提供 window、document 等 BOM 对象；小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整的浏览器对象，所以缺少相关的 DOM API 和 BOM API。2. 开发成本的不同H5 的开发，涉及到开发工具、前端框架、模块管理工具、任务管理工具、UI 库的选择、接口调用工具及浏览器兼容性等；小程序的开发，指定环境的小程序会提供开发者工具、API 及规范的开发标准。由于小程序是跑在指定的环境下的，同时 API 是指定环境下提供的，所以不用考虑浏览器的兼容性。在 H5 开发中，前端常用的 HTML/CSS 在不同的小程序中都有指定的文件标准。例如：在微信小程序中使用 WXML/WXSS；在支付宝小程序、钉钉 E 应用中使用 AXML/ACSS；在百度智能小程序中使用 SWAN/CSS；......开发规范在指定的官方文档中都会有明确的使用介绍，使用方法与原来 H5 的开发大同小异，所以上手开发相对容易。3. 使用体验的不同H5 页面需要在浏览器中渲染，在复杂的业务逻辑或者丰富的页面交互时会有卡顿情况；小程序除首次使用略慢，页面切换及跳转等非常顺滑，接近 Native。通过以上几点小程序和 H5 的不同的介绍，我们可以发现原来针对 H5 页面的监控无法直接监控小程序；同时由于小程序封闭性较强，不同的小程序在标准上也略有不同，如微信小程序、支付宝小程序及钉钉 E 应用等等小程序在使用标准及开放的 API 方面也会有一些差异，所以针对小程序的监控与针对 Web 应用的监控会有所不同。小程序监控的现状现在针对小程序监控的大概分为以下几类：1. 小程序的数据统计分析，助力小程序运营相关产品: 微信小程序助手、阿拉丁小程序统计平台等；特点：大部分是针对微信小程序提供相应的数据统计分析能力，从多维度分析小程序相关用户数据，适用于小程序运营，但缺乏对于用户体验，小程序性能的监控。2. 小程序错误监控相关产品: FunDebug 等；特点：监控小程序使用户出现的错误，帮助开发者发现并解决小程序错误，但缺乏对于小程序全局性能的监控，对于缓慢请求，缓慢页面没法监测。3. 小程序性能监控相关产品: FrontJS、听云小程序监控等；特点：主要提供性能相关数据，包括 JS 错误、网络请求响应情况等。但是只支持微信小程序，而且没有办法把小程序的性能与后台应用的性能关联起来，没法形成端到端的监控。通过上面对现有的小程序监控产品分析，存在以下问题：无法支持所有的小程序监控，主要支持微信小程序；支持多类小程序监控的产品，提供的小程序相关数据较少，主要集中在错误监控；没有后台应用服务的性能监控，无法从小程序上的性能问题追溯到后台应用代码和数据库，无法形成端到端的监控。基于以上情况，阿里云 ARMS 前端监控重磅推出小程序监控，旨在帮助端到端的快速定位小程序问题，提升小程序的用户体验。小程序监控提供的能力阿里云 ARMS 前端监控此次重点推出的小程序监控有以下特点：1. 覆盖各类符合标准规范的小程序首先解释一下这里所说的\"标准规范的小程序\"，即包含 App 和 Page 两层:App 用来描述整体程序，包含: onError 事件；Page 用来描述各个页面，包含: onShow、onHide、onUnload 事件。小程序的运行环境依赖于对应的客户端，各类小程序的 DSL 设计看起来很像，但细节上的差别还是比较多，并且已有了分化的趋势。在这种情况下，阿里云 ARMS 前端监控为了更好的支持小程序的监控诉求，提供以下小程序监控的场景：微信小程序支付宝小程序钉钉 E 应用其他类别小程序由于小程序发展迅速，现在无法针对各类小程序都提供对应的监控 SDK，所以不属于微信小程序、支付宝小程序和钉钉 E 应用的小程序可选择其他类别小程序的场景接入进行监控，但要满足上面说的\"标准规范的小程序\"前提，同时支持 npm 包。2. 完善的性能监控指标基础业务指标，帮助了解小程序应用的使用情况：应用总 PV/UV页面维度的 PV/UV小程序各维度指标：手机型号操作系统版本微信 / 支付宝等相应的 APP 版本网络等JS 错误分析：JS 错误率、错误聚类、JS 错误堆栈及错误定位等API 请求追踪：API 请求成功率、API 请求耗时及 API 请求的链路追踪自定义事件统计支持业务上自定义事件 sum/avg 统计3. 可通过配置选择上报方式由于业务方使用监控的诉求不同，我们不仅支持优雅的静默数据上报，也支持使用开放的统计能力进行自定义上报。具体可查看官网的前端监控接入概述中的小程序场景相关文档：https://help.aliyun.com/document_detail/106086.html"}
{"title": "微信小程序框架wepy踩坑记录（与vue对比） ", "author": "Rolan", "pub_time": "2019-3-12 00:04", "content": "wepy框架借鉴了vue的语法风格和功能特性，但是在使用过程中还是发现与vue有很大的不同。现在总结一下自己开发中遇到的问题，共大家参考一下。如果第一次用wepy开发，强烈建议仔细阅读一下这篇文章，一定对你有帮助，会帮你节约很多宝贵的时间。开发过程中也建议大家时不时的回来阅读一次，巩固加强记忆。wepy中的组件组件里面的坑还不是一般的多！首先来说说组件间的数据共享。在vue中你也能做到这一点，只要把 data 写成一个对象就可以了，当然你不想让所有的子组件都共享同一份数据，vue中的解决方案是给 data 写成一个函数就好了，return出来所有的数据，这样组件间的数据就不会共享了。但是wepy中不能。文档中介绍： WePY中的组件都是静态组件，是以组件ID作为唯一标识的，每一个ID都对应一个组件实例，当页面引入两个相同ID的组件时，这两个组件共用同一个实例与数据，当其中一个组件数据变化时，另外一个也会一起变化。所以如果同一个页面引用多个组件，你只能给每个组件定义不同的ID，类似这样import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            //为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题\r\n            child: Child,\r\n            anotherchild: Child\r\n        };\r\n    }看起来是不是很蠢。但是没办法，你只能这么用。如果页面中只引用两三个同类型组件还好，但是如果我是一个循环，我也不知道我要引用多少组件，该怎么办？接下来再说说组件的循环。wepy官方文档中说明： 当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签<repeat> 。但是不支持在 repeat 的组件中去使用 props ,computed , watch 等等特性。什么？ props 都不让用？？那父组件如何给子组件传参？？后来实践发现，如果 props 中的数据在 template 中是能取到的，但是在 method 或者 event中就取不到了，你说神不神奇！所以最后的解决办法是用的 wepy-redux ，类似vuex，放在 store 中实现的。视图的渲染之异步数据异步数据的获取后需要手动调用 this.$apply() 方法才能重新渲染视图，这一点也一定要记得。刚开始做的时候是在页面 data 中写的假数据，渲染的好好的。但是数据换成从接口读取后，死活视图出不来。琢磨了半天才想起来需要手动调用 this.$apply() 。而 vue 是不需要这么做的。方法定义wepy中页面中的事件需要些在 methods 中，组件之间的处理函数需要写在 events 中，而自己写的自定义方法需要写在与 methods 同级中。不像vue，可以写在 methods 里。在 events 中写的函数，不需要在调用子组件的时候写在子组件中，子组件 $emit 会自动去 events 中寻找同名方法执行。这点也与vue不同。事件传参wepy优化了原生小程序在事件中的传参形式。比如页面中有一个方法，叫 getIndex ，目的是取一个循环的 index 属性，在原生中需要额外定义一个 data-index 属性，然后在 getIndex 中通过 event.currentTarget.dataset.index 来获取。而wepy中可以直接在事件里传递，但需要加上 {{}} ，写成 getIndex({{index}}) 这样，这点也与vue不同。数据绑定这个是小程序原生方法中的不好点，wepy不能帮忙背这个锅。数据绑定也是使用 {{}} ，但是{{}} 里面只能进行简单的运算，具体支持哪些运算可以看 官方文档 。需求是一个列表，选中的变个样式，正常的思路就是选中的时候触发一个方法，将 index 赋值给 currentActive ，在{{}} 中判断如果 currentActive == index 就应用 active 样式，命名很简单的一个需求。但是写好了就是不好使，找了半天也没发现哪错了，最后看文档，原来是根本就不支持这种写法！！只支持简单的运算，这种不属于简单的范围！！最后的解决办法是弄了一个数组 arr ，选中将对应位置置为 true ，在 {{}} 判断 arr[index] 是否为 true 解决了这个问题。总结一句话：{{}} 一点也不强大。动态绑定classwepy中需要遵循小程序原生的绑定方式，与vue中也不同。在vue中，动态的和非动态的需要分别写，类似这样： <div class=\"class-a\" :class=\"{true ? 'class-b': 'class-c'}\"></div> 。但是在wepy中，动态和非动态的可以写在一起，类似这样： <view class=\"class-a {{true ? 'class-b' : 'class-c'}}\">mixin混合wepy中的 mixin 分为两种。对于组件data数据， compontents 组件， events 事件及其他自定义方法采用默认式混合，即如果组件中未定义这些东西，那么 mixin 中的将生效，如果组件中已经定义了，将以组件中定义的为主， mixin 中定义的不会生效。但对于 methods 事件及小程序页面事件，将采用兼容式混合，只要定义了就都会生效。但是先响应组件中定义的，再响应 mixin 中定义的。而vue组件中 methods 里的事件如果与 mixin 中的重名，会采用组件中的事件。而生命周期的钩子函数则是先响应 mixin 中的，在响应组件中的。注：以上问题均是采用wepy1.7.2的版本，祝大家开发愉快，少踩些坑。最后附上官方文档链接，供大家参考：小程序官方文档wepy官方文档"}
{"title": "通过微信小程序扫码，在PC端登陆跳转相应页面 ", "author": "Rolan", "pub_time": "2019-3-21 00:20", "content": "通过微信小程序扫码，在PC端登陆跳转相应页面最近在做一个零食店，移动端采用微信小程序进行实现。当然，既然是零食店，那么肯定会有后台管理的，当时的想法是如何才能通过微信小程序里进行扫码去登陆PC端的管理平台呢？话不多说，接下来就说说我是怎么做到！ 首先，大致上讲一下我的实现思路，整体通过WebSocket来实现自动跳转。在PC登陆页，展示二维码，建立WebSocket连接，当微信小程序扫码后，在后台进行身份验证，并且将验证结果实时发送给在PC登陆页建立的websocket连接，然后进行相应信息的提示以及页面的跳转。扫码登陆流程1、生成PC端页面二维码 这个二维码中放的什么信息呢，当时是能够唯一标识客户端的UUID啦，不然你扫码之后，应该给哪个客户端发送状态信息呢 2、进入PC端管理页时，获取唯一标识，建立websocket连接，并且以该唯一标识作为key存放在map集合当中。pc端代码var websocket = null;    var url=\"ws://localhost:8080/snacks/socketLogin/[[${socketKey}]]\";    if('WebSocket' in window)        websocket = new WebSocket(url);    else        layer.msg(\"该浏览器暂不支持！请更换浏览器\",{icon:2,time:1000})    websocket.onopen = function () {    }    websocket.onclose = function () {        layer.msg(\"连接失效，请刷新页面\",{icon:2,time:1000})    }    websocket.onmessage = function (e) {        var res = e.data;        var mid = eval(\"var json = \"+res)        if(json.code==\"1000\"){            //登陆成功            layer.msg(\"登陆成功！\",{icon:1,time:1000},function () {                window.location.href = \"http://localhost:8080/snacks/login/goShopIndex/\"+json.openId+\"/snacks\";            })        }else{            //登陆失败            layer.msg(\"该用户暂时没有权限或者商户\",{icon:2,time:2000})        }    }服务器端代码private static ConcurrentHashMap<String, Session> sessionMap = new ConcurrentHashMap<>();@OnOpen    public void onOpen(Session session, @PathParam(\"socketKey\") String socketKey){        System.out.println(\"websocket:\"+socketKey+\"--->建立成功\");        sessionMap.put(socketKey,session);    }    @OnClose    public void onClose(Session session,@PathParam(\"socketKey\") String socketKey){        System.out.println(\"websocket:\"+socketKey+\"--->断开连接\");        sessionMap.remove(socketKey);    }然后呢就是微信小程序端了，微信小程序通过扫码获取到该PC登陆页建立的websocket连接的唯一标识Key后，将自己的信息与这个key作为data请求后台接口。在后台接口中对用户信息进行校验，之后将校验结果发送给该key对应的session连接就可以啦服务器端@RequestMapping(\"/getLoginCode\")    @ResponseBody    public Integer getLoginCode(HttpSession session, String socketKey, String openId){        //在这里进行登陆信息验证        。。。。。。        //获取到websocket连接session的map        ConcurrentHashMap<String, Session> sessionMap = LoginSocket.getSessionMap();        //将状态信息发送到客户端        Session currentSession = sessionMap.get(socketKey);        currentSession.getAsyncRemote().sendText(responseJson);        return result.getCode();    }微信小程序端scanCodeLogin:function(){    wx.scanCode({      scanType:'qrCode',      success:function(e){        var socketKey = e.result;        app.checkSession();        var openId = wx.getStorageSync(\"openId\");        wx.request({          url: app.baseUrl + '/getLoginCode',          method:'POST',          header:app.postHeader,          data:{socketKey:socketKey,openId:openId},          success:function(e){            console.log(e)          var result = e.data;          if(result == 1000){              wx.showToast({                title: '登陆成功',              })          }else{              wx.showModal({                title: '登陆失败',                content: '该用户暂时没有权限或者商户',                showCancel:false              })          }          }        })      },      fail:function(){      }    })这里的websocket也可以替换为消息队列中间件，但是这样是不是大材小用了呢？"}
{"title": "小程序性能优化的几点实践技巧 ", "author": "Rolan", "pub_time": "2019-4-2 00:21", "content": "大家好，我叫张文轩，这是我的第6篇分享我们都知道，性能的好坏直接影响用户的体验。本文首先论述下如何评判一个小程序页面的性能情况，之后通过具体的案例重点讲解下几点实践技巧，最后再讲讲key值在渲染一个列表时发挥了一个怎么样的作用，以此来论述为啥key值对性能提升有帮助。评判小程序页面性能由于小程序开发环境的特殊性，我们不能像普通网页那样通过chrome开发工具或者一些成熟的性能测试工具（例如Lighthouse）来了解一个页面的性能，但微信官方提供了一个性能评分的工具，点击这里可以查看工具详情。体验评分是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。后面我会以一个实际的例子来展示如何通过该工具来优化页面性能，我们先看下我们页面优化前的一个评分情况。存在setData的数据过大我们的功能里面有个滚动到底部加载的功能，优化前我们的做法是这样的<!--只阐述逻辑，非真实代码-->\r\n\r\n// 1: 初始一个list，存储列表数据\r\ndata = startList\r\n// 2: 监听滚动事件，滚动到底部获取新数据，并追加到list尾部,最后重新setData\r\nonReachBottom:()=>{\r\n    const {list} = this.data\r\n    fetchNewData().then((res)=>{\r\n        list.push(res.list);\r\n        this.setData({list})\r\n    }\r\n}\r\n复制代码我估计大部分人面对长列表滚动的时候，一开始的处理方式都是这样的，如果数据不多，只有几页可能不会太暴露问题，如果页数过多，几十页甚至上百页的情况，list的数据会越来越大，每次setData的数据就会越来越多，因而每次页面重新渲染的节点就会越来越多，从而导致滚动到后面，加载越来越慢。另外，由于小程序的视图渲染层和数据逻辑处理层是分开的，不是在同一个线程上面的，从用户触发页面交互，到处理数据逻辑，最后层现页面，数据到视图是需要传输的，因而小程序本身对数据大小也有限制，不能超过1M。setData数据路径怎么解决呢？小程序setData里面的key支持数据路径的写法，比如let o = obj;\r\nthis.setData({\r\n    'o.属性'：value\r\n})\r\n\r\n或者\r\nlet a = array;\r\nthis.setData({\r\n    'array[0].text':value\r\n})\r\n复制代码所以我们可以通过数据路径的写法，来将数据分批的传输到视图层中，减少一次性setData的数据大小。具体写法如下// 1.通过一个二维数组来存储数据\r\nlet feedList = [[array]];\r\n\r\n// 2.维护一个页面变量值，加载完一次数据page++\r\nlet page = 1\r\n\r\n// 3.页面每次滚动到底部，通过数据路径更新数据\r\nonReachBottom:()=>{\r\n    fetchNewData().then((newVal)=>{\r\n        this.setData({\r\n            ['feedList[' + (page - 1) + ']']: newVal,\r\n        })\r\n    }\r\n}\r\n// 4.最终我们的数据是[[array1],[array2]]这样的格式，然后通过wx:for遍历渲染数据\r\n复制代码存在短时间内发起太多图片请求（图片懒加载）这个应该好理解，就是渲染页面时，一次性发送了过多的图片请求，导致了同一时间发起了过多的http请求，http连接是非常耗时的，尤其是一次性发起这么多，并且一次性发起的http链接也是有限制的，比如chrome浏览器就限制一次性最多6个。所以在渲染页面时，不在视图范围内的图片我们不加载，只有元素出现在视图范围内了，再渲染。常规的做法是，通过 getBoundingClientRect() 获取元素的位置，然后与页面滚动位置比较，如果出现在视图内，就将 img 显示。这种方式有2个问题getBoundingClientRect()方法调用本身容易引起页面重排监听滚动事件本身就频繁触发，虽然可以通过节流的方式来减少，但还是容易增加无谓代码处理IntersectionObserver其实，微信提供了 IntersectionObserver 对象。IntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见通过这个api我们不用再主动去监听元素位置了，在页面渲染一开始，通过这个api指明需要监听的元素，系统会自动去监听了元素位置。let data = list;\r\n\r\n<img class=\"img-{{index}}\" wx:for=\"{{data}}\"></img>\r\n\r\ndata.forEach((item,index)=>{\r\n    this.createIntersectionObserver().relativeToViewport.observe(`.img-${index}`,res=>{\r\n        if (res.intersectionRatio > 0){\r\n            this.setData({\r\n                item.imgShow:true\r\n            })\r\n        }\r\n    })\r\n})\r\n\r\n复制代码intersectionRatio值大于0，说明元素出现在视图中了，重新setData数据，显示图片组件。存在图片太大而显示区域过小这个问题就是指图片尺寸太大了，而页面上我们显示的尺寸又太小了，图片尺寸大，请求图片就越慢，导致页面渲染速度下降。CDN图片处理对于页面里面的图片，最好都把图片存储在cdn服务器上，一个是能充分利用cdn缓存来加快请求速度，另外一个就是cdn上能够将图片进行一定的处理，比如裁剪。我司就是通过cdn来响应图片处理，然后请求图片时告诉cdn服务器需要什么要的尺寸图片，由cdn服务器响应对应尺寸图片。key值在列表渲染中的作用key值在列表渲染的时候，能够提升列表渲染性能，为什么呢？首先得想想小程序的页面是如何渲染的，主要分为以下几步：将wxml结构的文档构建成一个vdom虚拟数页面有新的交互，产生新的vdom数，然后与旧数进行比较，看哪里有变化了，做对应的修改（删除、移动、更新值）等操作最后再将vdom渲染成真实的页面结构key值的作用就在第二步，当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。key值如果不指明，默认会按数组的索引来处理，因而会导致一些类似input等输入框组件的值出现混乱的问题。相关测试代码可以查看：wxkey可以看到不加key,在数组末尾追加元素，之前已渲染的元素不会重新渲染。但如果是在头部或者中间插入元素，整个list被删除重新渲染，且input组件的值还出现了混乱，值没有正常被更新添加key，在数组末尾、中间、或者头部插入元素，其它已存在的元素都不会被重新渲染，值也能正常被更新因而，在做list渲染时，如果list的顺序发生变化时，最好增加key，且不要简单的使用数组索引当做key。最后看看我们的成果：体验码：希望今天我的分享能对您优化小程序页面有一定的启示，创造出性能更好更流畅的页面。最后如果喜欢我的文章，欢迎点击关注，我会不定期的分享自己的一些所看所想，和大家一起成长，持续学习。"}
{"title": "微信小程序内使用canvas绘制自定义折线图表 ", "author": "Rolan", "pub_time": "2019-4-10 00:54", "content": "话不多说，最终实现效果如下：图中难点：圆角矩形绘制；转载他人帖子：看此处：https://www.jb51.net/article/...最左或者最右边的气泡需要做动态偏移本项目是由mpvue写的小程序：所以用的是vue的书写格式（微信小程序可以自行修改）：使用方法：将下列代码新建linechart.vue文件再项目中调用本组件的drawAll方法传入日期和值即可代码中有少量注解请不懂的给我留言<template>\r\n    <div class=\"linechart\">\r\n        <canvas class=\"circle\"  canvas-id=\"canvasline\" style=\"width: 750rpx;height: 280rpx;\">\r\n        </canvas></div>\r\n</template>\r\n\r\n<script>\r\n     export default {\r\n         data() {\r\n            return {\r\n                canvasWidth: 375,\r\n                canvasHeight: 123,\r\n                date: ['-/-','-/-','-/-','-/-','-/-','-/-','-/-'],\r\n                value: [0,0,8,10,6,0,0,],\r\n                len: 4,\r\n                xcoords: []\r\n            }\r\n         },\r\n        onLoad() {\r\n            this.drawAll()\r\n        },\r\n        methods: {\r\n            drawAll(date, value) {\r\n                this.date = date || this.date\r\n                this.value = value || this.value\r\n                var ctx = wx.createCanvasContext('canvasline')\r\n                this.roundRect(ctx, this.px2PX(10), 0, this.px2PX(this.canvasWidth) - this.px2PX(20), this.px2PX(this.canvasHeight), this.px2PX(8), '#F5F3ED');\r\n                this.drawYLine(ctx, this.px2PX(20), 0, this.px2PX(20), this.px2PX(this.canvasHeight),this.px2PX(55), this.px2PX(1), 'white')\r\n                this.drawXLine(ctx, this.len, this.px2PX(1), 'white');\r\n                this.drawLine(ctx, this.px2PX(1.5), this.px2PX(3))\r\n                ctx.draw()\r\n            },\r\n            px2PX(px) { // px (Int) 375为设计稿宽度，根据屏幕动态设置像素大小解决模糊问题和适配\r\n                return  (wx.getSystemInfoSync().screenWidth / 375) * Number(px)\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} x 圆角矩形选区的左上角 x坐标\r\n              * @param {number} y 圆角矩形选区的左上角 y坐标\r\n              * @param {number} w 圆角矩形选区的宽度\r\n              * @param {number} h 圆角矩形选区的高度\r\n              * @param {number} r 圆角的半径\r\n              * @param {color} fillColor 填充的颜色\r\n            */\r\n            // 绘制矩形\r\n            roundRect(ctx, x, y, w, h, r, fillColor) {\r\n                if (w < 2 * r) r = w / 2;\r\n                if (h < 2 * r) r = h / 2;\r\n                // 开始绘制\r\n                ctx.beginPath()\r\n                // 因为边缘描边存在锯齿，最好指定使用 transparent 填充\r\n                // 这里是使用 fill 还是 stroke都可以，二选一即可\r\n                // ctx.setFillStyle('transparent')\r\n                // ctx.setStrokeStyle('transparent')\r\n                // 左上角\r\n                ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5)\r\n\r\n                // border-top\r\n                ctx.moveTo(x + r, y)\r\n                ctx.lineTo(x + w - r, y)\r\n                ctx.lineTo(x + w, y + r)\r\n                // 右上角\r\n                ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2)\r\n\r\n                // border-right\r\n                ctx.lineTo(x + w, y + h - r)\r\n                ctx.lineTo(x + w - r, y + h)\r\n                // 右下角\r\n                ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5)\r\n\r\n                // border-bottom\r\n                ctx.lineTo(x + r, y + h)\r\n                ctx.lineTo(x, y + h - r)\r\n                // 左下角\r\n                ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI)\r\n\r\n                // border-left\r\n                ctx.lineTo(x, y + r)\r\n                ctx.lineTo(x + r, y)\r\n                ctx.setFillStyle(fillColor);\r\n                // 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应\r\n                ctx.fill()\r\n                // ctx.stroke()\r\n                ctx.closePath()\r\n                // 剪切\r\n                // ctx.clip()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number, number, number, number} x1, y1, x2, y2 第一条线的起始坐标和结束坐标\r\n              * @param {number} spacing 线条直接的间隔\r\n              * @param {number} lineWidth 线条宽度\r\n              * @param {color} color线条的颜色\r\n            */\r\n            // 绘制竖线网格和底部文字\r\n            drawYLine(ctx, x1, y1, x2, y2, spacing, lineWidth, color) {\r\n                ctx.beginPath();\r\n                let width = this.px2PX(this.canvasWidth) - (x1 * 2)\r\n                let len = Math.floor(width /spacing)\r\n                for (let i = 0; i <= len; i++) {\r\n                    let spaced = spacing * i + i;\r\n                    this.xcoords.push(x1 + spaced)\r\n                    ctx.setLineWidth(lineWidth)\r\n                    ctx.setStrokeStyle(color)\r\n                    ctx.moveTo(x1 + spaced, y1);\r\n                    ctx.lineTo(x2 + spaced, y2);\r\n                    /* --- 底部标尺文字 -- */\r\n                    ctx.setFontSize(this.px2PX(12));\r\n                    ctx.setTextAlign('center');\r\n                    ctx.setFillStyle('#DFDACD');\r\n                    ctx.fillText(this.date[i], x1 + spaced, y2 + this.px2PX(14))\r\n                    /* ---- 底部标尺文字 --- */\r\n                }\r\n                ctx.stroke()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} len 绘制多少条横线\r\n              * @param {number} lineWidth 线条宽度\r\n              * @param {color} color线条的颜色\r\n            */\r\n            // 绘制横线网格\r\n            drawXLine(ctx, len, lineWidth, color) {\r\n                ctx.beginPath();\r\n                let spaced = this.px2PX(this.canvasHeight) / len\r\n                let x = this.px2PX(this.canvasWidth)\r\n                for (let i = 0; i < len; i++) {\r\n                    let hei = spaced * i + i\r\n                    ctx.moveTo(0, hei);\r\n                    ctx.lineTo(x, hei);\r\n                }\r\n                ctx.setLineWidth(lineWidth)\r\n                ctx.setStrokeStyle(color)\r\n                ctx.stroke()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} width 折线的线条宽度\r\n              * @param {number} r 折线拐角的圆的半径\r\n            */\r\n            // 绘制折线，折线区域，气泡，气泡文字\r\n            drawLine(ctx, width,r) {\r\n                let arrMax = Math.max.apply({},this.value)\r\n                let height = this.px2PX(this.canvasHeight)\r\n                let hei = this.px2PX(this.canvasHeight) - this.px2PX(24)\r\n                let average = arrMax <= 0 ? 0 : hei / arrMax\r\n                let len = this.value.length - 1\r\n                ctx.beginPath();\r\n                /* 折线 */\r\n                for (let i = 0; i < len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average, x2 = this.xcoords[i+1], y2 =  height - this.value[i + 1] * average\r\n                    ctx.moveTo(x1, y1)\r\n                    ctx.lineTo(x2, y2)\r\n                }\r\n                ctx.setStrokeStyle('#F9B213');\r\n                ctx.setLineWidth(width);\r\n                ctx.stroke()\r\n                /* 折线 */\r\n                /* 折线区域 */\r\n                ctx.beginPath();\r\n                for (let i = 0; i < len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average, x2 = this.xcoords[i+1], y2 = height - this.value[i + 1] * average\r\n                    ctx.moveTo(x1, y1)\r\n                    ctx.lineTo(x2, y2)\r\n                    ctx.lineTo(x2, height)\r\n                    ctx.lineTo(x1, height)\r\n                }\r\n                /* 折线区域 */\r\n                ctx.setFillStyle('rgba(249,178,19,0.08)');\r\n                ctx.fill();\r\n                \r\n                for (let i = 0; i <= len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average\r\n                    ctx.beginPath();\r\n                    ctx.arc(x1, y1, r, 0, 2 * Math.PI)\r\n                    ctx.setStrokeStyle('#F9B213');\r\n                    ctx.setLineWidth(width);\r\n                    \r\n                    ctx.setFillStyle('white');\r\n                    ctx.fill();\r\n                    ctx.stroke()\r\n                }\r\n                for (let i = 0; i <= len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average\r\n                    let defaultWidth = this.px2PX(24), defaultHeight = this.px2PX(16)\r\n                    let fontsize = this.px2PX(10)\r\n                    let lense = this.value[i].toString().length\r\n                    if (lense > 1) {\r\n                        defaultWidth = defaultWidth + lense * fontsize / 2.5\r\n                    }\r\n                    let x = x1 - defaultWidth / 2\r\n                    let y = y1 - defaultHeight - r * 2\r\n                    if (i === 0) { // 第一个文字tip向右\r\n                        x = x1 - fontsize / 2\r\n                        ctx.setTextAlign('left');\r\n                    } else if (i === len) { // 最后一个文字tip向左\r\n                        x = x - defaultWidth / 2 + fontsize / 2\r\n                        ctx.setTextAlign('right');\r\n                    } else {\r\n                        ctx.setTextAlign('center');\r\n                    }\r\n                    this.roundRect(ctx, x, y, defaultWidth, defaultHeight, this.px2PX(8), 'white')\r\n                    ctx.beginPath();\r\n                    ctx.setFontSize(fontsize);\r\n                    ctx.setFillStyle('#F9B213');\r\n                    ctx.fillText('+'+this.value[i], x1, y1 - this.px2PX(10))\r\n                    ctx.closePath()\r\n                }\r\n            }\r\n        }\r\n     }\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n    .linechart {\r\n        width: 750upx;\r\n        height: 280upx;\r\n    }\r\n</style>\r\n以上列子如有疑问，请给我留言。"}
{"title": "云开发有“黑洞”？日语用例助手实例教你避坑 ", "author": "Rolan", "pub_time": "2019-4-17 00:11", "content": "4月10日晚人类首张黑洞照片发布，然而对开发者来说，下图才是他们心目中的黑洞。开发中遇到的bug永远是一个深不见底的黑洞。为了不让大家在开发中踩坑，我们今天特地为你们带来一篇以“日语用例助手”为例的云开发实战避坑指南。转载来源：云开发x原作者：Evont前言小程序开放了云开发能力，为开发者提供了一个可以很快速构建小程序后端服务的能力，作为一名对新技术不倒腾不快的前端，对此也是很感兴趣的。Taro 是凹凸实验室推出的，基于React 语法规范的多端开发解决方案，较之于mpvue或者wepy，由于年轻，坑还比较多，但是很适合我这种倾向用React 开发的人。我结合这两者，使用cheerio和superagent 抓取了用例.jp， 开发了一个《日语用例助手》。入门踩坑1.云开发篇1.1 环境搭建云开发可以通过下列两种方式创建：1.使用quickstart（云开发快速启动模版）创建项目：这种方式会在目录下同时创建名为miniprogram ，带有云开发调用范例的小程序基础模板和名为cloudfuntions 的存放云函数的目录, 由此即可开始全新的项目。2.基于现有的小程序使用云开发：在小程序目录下创建一个文件夹作为你的云函数目录，然后在project.config.json 文件中新增字段\"cloudfunctionRoot\":\"你的云函数目录\"，即可以在微信开发者工具中看到目录的图标变成了云，在此目录下创建云函数即可；\r\n1.2 云函数编写使用微信开发者工具在云函数目录下创建一个云函数时，会根据名称创建一个目录，目录中包含一个index.js 和package.json。在小程序中使用如下方式调用云函数：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      key1: 'value1',\r\n      key2: 'value2'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((e) => {\r\n    console.log(e);\r\n});\r\nindex.js的入口函数如下所示：//云函数入口函数\r\nexports.main =async (event,context)=>{\r\n    // 参数获取在event 中获取，如使用上面的调用函数后，获取data使用 event.key1、event.key2即可\r\n    const { key1, key2 } = event;\r\n    return { query: { key1, key2 } }\r\n}\r\n每个云函数可视为一个单独的服务，如果需要安装第三方依赖，只需要在该目录点击右键，选择 在终端中打开, 并 npm install依赖即可。需要注意的是，每个云函数都是独立的，所需要的依赖都需要在对应的目录下进行 npm install，但这样就会使得项目变得十分庞大且不优雅。因此，接下来我介绍一下tcb-router。1.3 使用tcb-router管理路由tcb-router 是腾讯云团队开发的，基于 koa 风格的小程序·云开发云函数轻量级类路由库，主要用于优化服务端函数处理逻辑。使用tcb-router的方法很简单：const TcbRouter = require('tcb-router');\r\nexports.main = (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    app.router('路由名称', async (ctx) => {\r\n        //原有的event需要通过ctx._req.event 获取\r\n        const { param1, param2 } = ctx._req.event;\r\n        ctx.body = { key1: value1 };\r\n    });\r\n})\r\n此时小程序的调用方式也需要改成：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      $url: '路由名称',\r\n      // 其他数据\r\n      param1: 'test1',\r\n      param2: 'test2'\r\n    },\r\n    success: res => {},\r\n    fail: err => {\r\n      console.error(`[云函数] [${action}] 调用失败`, err)\r\n    }\r\n})\r\n2.Taro篇2.1 环境搭建npm install -g @tarojs/cli\r\ntaro init myApp\r\n2.2 遇到的坑1.API支持不足由于Taro 对微信的一些新api 并没有支持到，比如使用云开发时需要用到 wx.cloud，Taro 并没有支持，但亲测是可以直接使用 wx 变量，但是会被eslint 提醒，看着十分不悦，可以在 .eslintrc 文件中增加以下代码：\"globals\": {\r\n  \"wx\": true\r\n},\r\n2.不能使用 Array#map 之外的方法操作 JSX 数组。3.不允许在 JSX 参数(props)中传入 JSX 元素(taro/no-jsx-in-props)。3.爬虫篇3.1 superagentsuperagent 是一个非常实用的http请求模块，用来抓取网页十分有用，使用也十分简单，以下是我在抓取 yourei.jp 时使用的代码：// const superagent = require('superagent');\r\n// ...\r\nfunction crawler(url, cb) {\r\n  return new Promise((resolve, reject) => {\r\n    superagent.get(url).set({\r\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'\r\n    }).end(function (err, res) {\r\n      if (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n      resolve(res);\r\n    });\r\n  });\r\n}\r\n3.2 cheeriocheerio 是一个轻型灵活，类jQuery的对HTML元素分析操作的工具。在进行一些server端渲染的页面以及一些简单的小页面的爬取时，cheerio十分好用且高效。在使用 superagent 抓取了网页内容后，可以使用如下方式解析页面代码:// const cheerio = require('cheerio');\r\n// ...\r\nconst result = crawler(apiUrl).then((res) => {\r\n  // 使用load 之后，$ 即可同jquery 一样使用选择器来选择元素了\r\n  const $ = cheerio.load(res.text);\r\n  const categories = [];\r\n  $('[data-toggle]').each((i, ele) => {\r\n    // 可以使用.text()、.html() 等方式获取元素的内容\r\n    categories.push($(ele).attr('href'));\r\n  });\r\n  return {\r\n    list: categories,\r\n  };\r\n});\r\n总结1.Taro如果你是React 开发者，需要开发多端小程序，或者原有React 项目想迁移到小程序，Taro 是个不错的选择，但还有很多坑没有填好，希望它的发展越来越好。2.云开发如果你是个人开发者，想尝试小程序开发又不想或者难以自己搭建服务器，云开发是个好选择，容易上手且十分敏捷。"}
{"title": "微信小程序如何将图片画到canvas中 ", "author": "Rolan", "pub_time": "2019-4-17 00:16", "content": "微信小程序开发第二弹:canvas是新的h5标签，相信在前端技术中大家使用的已经非常多了，但是在微信小程序开发中，应该如何将图片置入canvas中呢?这篇经验来和大家分享一下!工具/原料微信web开发者工具方法/步骤1:先是照样先写好一个html文件，不过由于是微信小程序，所以要按照wxml的标准来写。头尾文件都不需要，直接修改index.wxml,方法/步骤2:寻找一张准备置入的图片，保存在网络环境中。可以转换成base64，也可以保存在自己的服务器端。本地调试的时候需要使用。我就拿这个小黄人来举例吧。方法/步骤3:在canvas内进行图像绘制，要先定义一个函数。方法/步骤4:我们先建立一个动作，将图片置入进去。引用函数context.drawImage()函数即可，但是要调整图片大小;方法/步骤5:但是不能使用draw(true)来进行铺满，所以尺寸必须自己来指定，或者使用js来读取device的height和width。使图片达到预想的效果。方法/步骤6:微信小程序的WXML和HTML格式有点差别，不能直接调用函数，所以必须使用匿名函数的形式，或者直接绑定事件。方法/步骤7:最后是进行不同机型的调试，在微信开发工具左上方可以调整，主要是看不同尺寸显示问题，如果有必要还要进行wifi，4G，2G测试注意事项使用context.drawImage();的时候，还需要限制起始位置与图片大小这里仅仅提供思路，如果是制作页面，还需要使用wx.downloadFile"}
